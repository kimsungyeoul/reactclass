# ⚛️ React JSX

JSX는 단순히 “HTML처럼 보이는 문법”이 아닙니다.
**React 렌더링 모델을 완전히 바꿔놓은 선언적 UI DSL(Domain-Specific Language)** 입니다.
즉, JSX는 HTML이 아니라 **JavaScript의 확장 문법이며, 결국 JavaScript로 컴파일되는 표현식**입니다.

---

## 1. JSX란? 🤔

### 1.1 정의

* **JSX (JavaScript XML)** 는
  **자바스크립트 코드 안에서 XML/HTML처럼 보이는 문법으로 UI 구조를 표현하는 확장 문법**입니다.
* 하지만 브라우저는 JSX를 직접 이해하지 못합니다.

  * 빌드 도구(Vite, Webpack) + Babel에 의해
    **평범한 자바스크립트 함수 호출 코드**로 변환됩니다.

요약하면:

> JSX = 사람이 읽고 쓰기 좋은 UI DSL
> (컴파일되면 → React.createElement 혹은 JSX 런타임 호출)

---

## 2. JSX는 결국 무엇으로 변환될까? 🔧

### 2.1 대표적인 변환 예시

```jsx
// JSX
const element = <h1 className="title">Hello, JSX</h1>;
```

빌드 단계에서 대략 다음과 같이 변환됩니다(개념적 예시):

```js
// 변환 후 (옛 방식)
const element = React.createElement(
  'h1',                          // type (DOM 태그)
  { className: 'title' },        // props 객체
  'Hello, JSX'                   // children
);
```

React 17+ 에서 도입된 **새 JSX 트랜스폼**에서는 내부적으로 조금 다른 함수가 호출되지만,
**핵심 아이디어는 같다**고 보시면 됩니다.

즉, JSX는:

* 첫 번째 아규먼트: `type` (DOM 태그 문자열 또는 컴포넌트 함수/클래스)
* 두 번째 아규먼트: `props` 객체
* 세 번째 이후 아규먼트: `children`들

을 아규먼트로 가지는 함수 호출 문법입니다.

---

## 3. JSX의 태그와 대소문자 규칙 🏷️

### 3.1 소문자 태그: DOM 요소

```jsx
<div />
<span>텍스트</span>
<button>Click</button>
```

* 소문자로 시작: `"div"`, `"span"` 과 같은 **HTML DOM element**로 인식됩니다.
* 변환 시 type 아규먼트가 문자열이 됩니다.

```js
React.createElement('div', null)
```

### 3.2 대문자 태그: React 컴포넌트

```jsx
<Card />
<UserProfile />
```

* 대문자로 시작: **사용자 정의 컴포넌트**로 인식됩니다.
* 변환 시 type 아규먼트는 **변수(식별자)** 가 됩니다.

```js
React.createElement(Card, null)
React.createElement(UserProfile, null)
```

이 규칙 때문에, 컴포넌트 이름을 반드시 **대문자로 시작**하게 만드는 것입니다.

---

## 4. JSX에서 “JSX Attribute 문법”과 “JSX Children 문법” 🔑

사용자님이 많이 궁금해하셨던 부분이 여기입니다.

### 4.1 JSX Attribute 문법

```jsx
<Card title="Profile" foo={123} />
```

이 한 줄은 **“Card라는 컴포넌트(함수)를 어떤 아규먼트로 호출하느냐”** 를 정의하는 문법입니다.

* `title="Profile"`
  → 문자열 리터럴
  → props.title에 `"Profile"` 저장
* `foo={123}`
  → 자바스크립트 표현식
  → props.foo에 `123` 저장

**변환 후 개념:**

```js
React.createElement(Card, {
  title: 'Profile',
  foo: 123,
});
```

즉, **Attribute들은 결국 하나의 `props` 객체 리터럴로 모입니다.**

---

### 4.2 JSX Children 문법

```jsx
<Card title="Profile">
  <UserProfile />
  <ActionButtons />
</Card>
```

이 코드를 “함수 호출” 시점으로 풀어서 보시면:

1. `Card` 라는 컴포넌트를
2. `title: 'Profile'` 이라는 props와
3. **children으로 `<UserProfile />`, `<ActionButtons />` 두 개를 전달**

하는 호출입니다.

**변환 후 개념:**

```js
React.createElement(
  Card,                          // type
  { title: 'Profile' },          // props
  React.createElement(UserProfile, null),     // children[0]
  React.createElement(ActionButtons, null)    // children[1]
);
```

그리고 React 내부에서는 이 세 번째 이후 아규먼트들을 모아서
`props.children`으로 제공합니다.

* children이 한 개 → `props.children` 은 단일 값
* children이 여러 개 → `props.children` 은 배열

정리하면:

> 1. **JSX Attribute 문법**: `<Card title="Profile" foo={123} />`
>    → `{ title: 'Profile', foo: 123 }` 라는 props 객체를 만드는 문법
>
> 2. **JSX Children 문법**: `<Card> ...내용... </Card>`
>    → `props.children` 을 채우는 문법

---

## 5. JSX 안에서의 `{ }` 표현식 규칙 🧠

JSX에서 **중괄호 `{ }`**는
“**여기 안은 자바스크립트 표현식 영역이다**” 라는 뜻입니다.

### 5.1 사용 가능한 것 (표현식)

```jsx
const name = 'React';
const element = <h1>Hello, {name}!</h1>;

const element2 = <p>{1 + 2 + 3}</p>;

const element3 = <div>{isLoggedIn ? 'Welcome' : 'Guest'}</div>;
```

* 변수 참조
* 산술 연산 (`1 + 2`)
* 삼항 연산자 (`조건 ? A : B`)
* 함수 호출 (`fn()`)
* 배열/객체 리터럴 (`{ [1,2,3] }`, `{ { foo: 1 } }`)

등 **“값을 만들어내는 표현식”** 은 모두 사용 가능합니다.

### 5.2 사용 불가능한 것 (문장, 선언)

```jsx
// ❌ 안 됨
<div>{ if (isOk) { ... } }</div>
<div>{ for (let i=0; i<10; i++) { ... } }</div>
<div>{ const x = 10 }</div>
```

* `if`, `for`, `const` 같은 것은 **문장(statement)** 이라서
  JSX 중괄호 안에 직접 들어갈 수 없습니다.
* 이럴 때는 JSX 밖에서 계산하거나,
* 삼항 연산자 / 논리 연산자(`&&`) 등을 활용합니다.

---

## 6. JSX Attribute 문법 자세히 보기 📝

### 6.1 문자열과 중괄호

```jsx
// 문자열 리터럴
<button type="button">Click</button>

// JS 표현식
<button type={buttonType}>Click</button>
```

* `"text"` : 그냥 문자열
* `{expression}` : 자바스크립트 표현식의 평가 결과 값

### 6.2 Boolean props

```jsx
// true로 간주
<input disabled />
// 동일 의미
<input disabled={true} />

// false
<input disabled={false} />
```

* **값 없이 이름만 쓰면 `true`**
* `false` 로 주고 싶을 때는 `disabled={false}` 처럼 명시해야 합니다.

### 6.3 className, htmlFor

JSX에서 HTML attribute 명과 조금 다른 이름을 쓰는 대표적인 케이스입니다.

* `class` → `className`
* `for` → `htmlFor`

```jsx
<label htmlFor="userName" className="label">
  Name
</label>
<input id="userName" />
```

이건 자바스크립트 예약어(`class`)와의 충돌 문제,
DOM property 이름과의 일관성 때문에 이렇게 되어 있습니다.

### 6.4 style 속성: 객체 리터럴

```jsx
const style = {
  backgroundColor: 'black',
  color: 'white',
};

<div style={style}>Styled</div>

// 바로 객체 리터럴도 가능
<div style={{ backgroundColor: 'black', color: 'white' }}>Styled</div>
```

* CSS `background-color` → JSX `backgroundColor` (camelCase)
* `style` 값은 **문자열이 아니라 JS 객체**입니다.

### 6.5 이벤트 핸들러

```jsx
<button onClick={handleClick}>Click</button>
```

* 이벤트 이름은 **camelCase** (`onclick` ❌, `onClick` ✅)
* 값으로 **함수(참조)** 를 넘겨야 합니다.

  * `onClick={handleClick}` ✅
  * `onClick={handleClick()}` ❌ (렌더링 시점에 바로 실행됨)

---

## 7. JSX Children 문법 자세히 보기 📦

### 7.1 텍스트, 태그, 표현식

```jsx
<Card>
  Hello
  <UserProfile />
  {isAdmin && <AdminBadge />}
</Card>
```

* 문자열 → 텍스트 노드 children
* `<UserProfile />` → 자식 컴포넌트
* `{isAdmin && <AdminBadge />}` → 조건부 children

### 7.2 배열도 children이 될 수 있음

```jsx
const items = ['a', 'b', 'c'];
<ul>
  {items.map(item => <li key={item}>{item}</li>)}
</ul>
```

* `map` 결과는 `[<li>...</li>, <li>...</li>, ...]` 배열
* 이 배열이 그대로 children으로 들어가면서 리스트가 렌더링됩니다.
* 이때 각 요소에는 `key`가 필요합니다. (리스트 diff 최적화용)

### 7.3 Fragment 사용

형제 요소 여러 개를 반환해야 할 때:

```jsx
// React.Fragment 사용
return (
  <React.Fragment>
    <h1>Title</h1>
    <p>Content</p>
  </React.Fragment>
);

// 축약 문법
return (
  <>
    <h1>Title</h1>
    <p>Content</p>
  </>
);
```

* Fragment는 실제 DOM에 추가 태그를 만들지 않고
  **여러 children을 묶기 위한 컨테이너** 역할만 합니다.

---

## 8. JSX = “함수 호출 문법”으로 이해하기 🧩

### 8.1 컴포넌트 정의

```jsx
function Card(props) {
  return (
    <div className="card">
      <h2>{props.title}</h2>
      <div>{props.children}</div>
    </div>
  );
}
```

### 8.2 컴포넌트 사용 (JSX)

```jsx
<Card title="Profile">
  <UserProfile />
  <ActionButtons />
</Card>
```

### 8.3 이걸 “순수 자바스크립트”로 바꿔보면

```js
const element = React.createElement(
  Card,
  { title: 'Profile' },
  React.createElement(UserProfile, null),
  React.createElement(ActionButtons, null)
);

// 그리고 React가 렌더링 과정에서
// 실제 DOM 구조를 만들어 줍니다.
```

즉, JSX를 머릿속에서 이렇게 이해하시면 훨씬 명확해집니다:

> `<Card ...>...</Card>`
> == `Card` 함수(컴포넌트)를 **특정 아규먼트(props, children)** 로 호출하는 **문법적 설탕(syntax sugar)**

---

## 9. 리스트와 key 🔑

### 9.1 기본 패턴

```jsx
const todos = [
  { id: 1, text: '밥 먹기' },
  { id: 2, text: '리액트 공부' },
];

<ul>
  {todos.map(todo => (
    <li key={todo.id}>{todo.text}</li>
  ))}
</ul>
```

* `map` 내부의 JSX도 결국 `React.createElement`의 배열
* `key`는 React가 **리스트를 diff 할 때 요소 식별에 사용하는 힌트**

### 9.2 key의 규칙

* 형제 사이에서 **유일(unique)** 하면 됨.
* index를 key로 쓰는 것은 가급적 피하는 것이 좋습니다.

  * 요소 추가/삭제 시 index가 바뀌면서 **예상치 못한 재사용**이 일어날 수 있음.

---

## 10. 조건부 렌더링 패턴들 ⚖️

JSX는 “표현식”만을 허용하므로, 보통 아래와 같이 작성합니다.

### 10.1 `&&` 패턴

```jsx
{isLoggedIn && <p>Welcome!</p>}
```

* `isLoggedIn`이 `true` → `<p>Welcome!</p>` 렌더
* `false` → `false` (렌더링에서 무시)

### 10.2 삼항 연산자

```jsx
{isLoggedIn ? <UserMenu /> : <LoginButton />}
```

### 10.3 `null` 반환

컴포넌트 함수 자체에서:

```jsx
function Banner({ visible }) {
  if (!visible) {
    return null;    // 아무것도 렌더링하지 않음
  }

  return <div>Banner</div>;
}
```

---

## 11. 고급 JSX 패턴 ✨

### 11.1 Spread props

```jsx
const baseProps = {
  type: 'button',
  className: 'btn',
};

<button {...baseProps} onClick={handleClick}>
  Click
</button>
```

* `{...baseProps}`
  → `type="button" className="btn"` 을 한 번에 펼치는 문법
* 나중에 오는 props가 이전 것을 **덮어씁니다.**

```jsx
<button {...baseProps} type="submit">
  Submit
</button>
// 결과 props.type === 'submit'
```

### 11.2 JSX를 변수에 담기

```jsx
const content = isError ? (
  <p className="error">에러 발생</p>
) : (
  <p>정상입니다.</p>
);

return <div>{content}</div>;
```

* JSX 표현식 자체가 **값**이므로, 변수/상수에 담아서 재사용할 수 있습니다.

### 11.3 함수로 JSX 조합하기

```jsx
function renderStatus(status) {
  switch (status) {
    case 'loading':
      return <p>Loading...</p>;
    case 'error':
      return <p className="error">Error!</p>;
    default:
      return null;
  }
}

function App() {
  return <div>{renderStatus(state.status)}</div>;
}
```

---

## 12. JSX에서 자주 하는 실수와 주의사항 🚨

1. **여러 root 요소 반환하기**

   ```jsx
   // ❌
   return (
     <h1>Title</h1>
     <p>Content</p>
   );

   // ✅ Fragment로 감싸기
   return (
     <>
       <h1>Title</h1>
       <p>Content</p>
     </>
   );
   ```

2. **`class` 대신 `className`**

   ```jsx
   // ❌
   <div class="box"></div>

   // ✅
   <div className="box"></div>
   ```

3. **이벤트 핸들러에 함수 “호출 결과”를 넘기는 실수**

   ```jsx
   // ❌: 렌더링 시 바로 실행됨
   <button onClick={handleClick()}>Click</button>

   // ✅: 함수 참조를 넘김
   <button onClick={handleClick}>Click</button>

   // 아규먼트가 필요하면 람다 사용
   <button onClick={() => handleClick(id)}>Click</button>
   ```

4. **JSX 안에서 if/for 직접 사용**

   ```jsx
   // ❌
   <div>
     {if (isOk) { ... }}
   </div>

   // ✅ JSX 밖에서 처리
   let content = null;
   if (isOk) {
     content = <p>Ok</p>;
   }

   return <div>{content}</div>;
   ```

5. **Props 변경 시도**

   ```jsx
   function Card(props) {
     // ❌ props는 읽기 전용
     // props.title = 'Changed';

     // ✅ 새로운 값으로 렌더링하고 싶다면 부모에서 props를 다시 넘겨야 함
     return <h2>{props.title}</h2>;
   }
   ```

---

## 13. 정리 🧾

* JSX는 **HTML이 아니고**, **자바스크립트 함수 호출을 표현하는 문법**입니다.
* `<Card title="Profile" foo={123} />`
  → **JSX Attribute 문법**으로 `{ title: 'Profile', foo: 123 }` 라는 props 객체를 만드는 것
* `<Card> ...children... </Card>`
  → **JSX Children 문법**으로 `props.children` 을 채우는 것
* 빌드 시에는 모두 `React.createElement(type, props, ...children)` 형태의 함수 호출로 변환됩니다.
* `{}` 안에는 오직 “표현식”만 사용할 수 있고,
  문자열/객체/배열/함수호출 등은 가능하지만 `if`, `for`, `const` 같은 “문장”은 직접 사용 불가합니다.
* `className`, `htmlFor`, camelCase style, 이벤트 핸들러 규칙 등
  **DOM과 JS의 세계를 자연스럽게 연결하기 위한 규칙**들이 있습니다.


