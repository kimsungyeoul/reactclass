리액트의 **`useMemo`**는 “생각보다 훨씬 많이 오해받는 훅”입니다.
“성능 최적화용 훅” 정도로만 알고 지나가면, 실제로는 **넣어도 효과가 없거나 오히려 코드를 복잡하게 만드는** 경우가 많아요.
이번 글에서는 진짜로 실무에서 쓸 수 있을 정도로, 내부 동작 관점까지 깊게 정리해보겠습니다. 💡

---

## 1. useMemo 한 줄 정의 🧠

> **`useMemo`는 “비싼 계산의 결과값”을 메모이제이션해서,
> 의존성이 변하지 않는 한 **다시 계산하지 않고 캐시된 값을 재사용하는 훅**입니다.**

```ts
const memoizedValue = useMemo(
  () => {
    // 💡 "비싼 계산"을 하는 함수
    return computeExpensiveValue(a, b);
  },
  [a, b]  // 의존성 배열
);
```

* `a`, `b`가 **바뀌지 않으면**

  * `computeExpensiveValue`는 **다시 실행되지 않고**
  * 이전에 계산해둔 `memoizedValue`를 그대로 사용합니다.
* `a` 또는 `b` 중 하나라도 **바뀌면**

  * 함수를 다시 실행해서 값을 계산하고
  * 그 결과를 새로 캐시합니다.

---

## 2. 왜 useMemo가 필요한가? – 렌더링과 “비싼 계산” ⚙️

리액트 **함수 컴포넌트**는 그냥 “함수”입니다.

```tsx
function MyComponent(props) {
  // 1. 함수 몸체가 실행된다 (렌더링)
  // 2. JSX를 반환함
  return <div>...</div>;
}
```

이때 컴포넌트 함수 안에서 이런 일을 한다고 가정해봅시다:

* 큰 배열을 정렬 / 필터링
* 복잡한 통계, 수학 계산
* JSON 파싱/포매팅
* 큰 데이터 구조를 새로 만드는 작업 등

```tsx
function Report({ data }) {
  // ⛔ 데이터가 바뀌지 않았어도, 렌더링마다 실행됨
  const summary = heavySummaryCalculation(data); // O(n^2) 같은 거라고 상상...

  return <SummaryView summary={summary} />;
}
```

* 부모가 렌더링 → 이 컴포넌트도 함께 렌더링 → `heavySummaryCalculation` 매번 실행
* 데이터가 안 바뀌어도 렌더링되면 다시 계산됨
* 이런 경우, **계산 결과를 캐시하고 재사용**하면 좋겠죠?

그래서 나온 것이 **`useMemo`**입니다. ✅

---

## 3. 기본 문법 정리 📚

```ts
const memoizedValue = useMemo(
  create: () => T,
  deps: DependencyList
);
```

* `create`

  * 리턴값: **메모이제이션할 값**
  * 규칙: **부수 효과(사이드 이펙트)를 넣으면 안 됨**

    * `fetch`, `setTimeout`, DOM 조작, `setState` 등은 ❌
    * 그런 건 `useEffect`에 넣어야 함
* `deps`

  * 이 배열의 값들이 **이전 렌더링과 “다르다”고 판단될 때만** `create`를 다시 실행
  * 비교는 **`Object.is`**로 함 (===와 거의 같지만 일부 케이스 다름: +0/-0, NaN 등)

---

## 4. 대표적인 사용 시나리오 4가지 🌈

### 4-1. 비싼 계산 최적화 (가장 교과서적인 용도) 💣

```tsx
import { useMemo } from "react";

function ExpensiveChart({ data }) {
  const processed = useMemo(() => {
    console.log("🚀 비싼 계산 실행!");
    return heavyProcess(data); // O(n^2) 정도로 가정
  }, [data]);

  return <Chart data={processed} />;
}
```

* `data`가 바뀔 때만 `heavyProcess`를 다시 실행
* 그 외의 렌더링(부모가 다른 이유로 렌더링됨)에서는

  * **이전 `processed` 값을 재사용** → 불필요한 계산 방지

---

### 4-2. 필터링/정렬된 배열 캐시 🧮

목록 렌더링에서 자주 나오는 패턴입니다.

```tsx
function UserList({ users, onlyActive, sortBy }) {
  const filteredAndSorted = useMemo(() => {
    let result = users;
    if (onlyActive) {
      result = result.filter((u) => u.isActive);
    }
    if (sortBy === "name") {
      result = [...result].sort((a, b) => a.name.localeCompare(b.name));
    }
    if (sortBy === "age") {
      result = [...result].sort((a, b) => a.age - b.age);
    }
    return result;
  }, [users, onlyActive, sortBy]);

  return (
    <ul>
      {filteredAndSorted.map((u) => (
        <li key={u.id}>{u.name}</li>
      ))}
    </ul>
  );
}
```

* `users`, `onlyActive`, `sortBy` 중 하나가 바뀌지 않는 한

  * 이 필터/정렬 로직은 **한 번만 실행**됨
* 특히 `users`가 큰 배열일수록 유의미한 최적화가 됩니다.

---

### 4-3. “참조 동일성(referential equality)” 보장하기 🔗

이게 실무에서 **가장 중요하지만 잘 안 알려진 사용법**입니다.

JS에서 **객체/배열**은 “값이 같아 보여도” **참조(주소)가 다르면 다른 것**입니다.

```js
{} === {}           // false
[1, 2] === [1, 2]   // false
```

그래서 이런 패턴은 번번이 훅/자식 컴포넌트를 쓸 때 문제를 일으킵니다:

```tsx
function Parent({ theme }) {
  const style = {
    color: theme === "dark" ? "white" : "black",
    background: theme === "dark" ? "#333" : "#fff",
  };

  return <Child style={style} />;
}
```

* 렌더링할 때마다 `style` 객체는 **새로 생성**
* `Child`가 `React.memo`로 감싸져 있어도,

  * `props.style`이 매번 **새 객체**라서 “바뀐 것”으로 인식 → 다시 렌더링

이때 `useMemo`로 참조를 고정할 수 있습니다.

```tsx
function Parent({ theme }) {
  const style = useMemo(
    () => ({
      color: theme === "dark" ? "white" : "black",
      background: theme === "dark" ? "#333" : "#fff",
    }),
    [theme] // theme이 바뀔 때만 새 객체 생성
  );

  return <Child style={style} />;
}
```

* 이제 `theme`가 바뀌지 않는 한 `style`은 **항상 같은 참조**
* `Child`를 `React.memo(Child)`로 감싸면 불필요한 재렌더링 줄일 수 있음

---

### 4-4. useEffect / useCallback 의존성에서 객체/배열 안정화하기 🧩

```tsx
function SearchBox({ onSearch }) {
  const [keyword, setKeyword] = useState("");
  const options = { debounce: 300, minLength: 2 };

  useEffect(() => {
    onSearch(keyword, options);
  }, [keyword, options]); // ⛔ options는 매 렌더링마다 새 객체
}
```

* `options`는 렌더링마다 `{ debounce: 300, minLength: 2 }` 새로 생성
* 그 결과 **`keyword`가 바뀌지 않아도** `options` 때문에 `useEffect`가 계속 실행됨

이때:

```tsx
const options = useMemo(
  () => ({ debounce: 300, minLength: 2 }),
  []
);

useEffect(() => {
  onSearch(keyword, options);
}, [keyword, options]); // ✅ 이제 options는 항상 같은 참조
```

* `options`는 **마운트 이후 항상 동일한 참조** 유지
* 이제 `keyword`가 바뀔 때만 `useEffect` 실행

---

## 5. 내부 동작 원리 – hook 메모리 슬롯과 memoizedState 🔍

함수 컴포넌트의 훅들은 내부적으로 **“훅 슬롯(hook slot)”**에 저장됩니다.

아주 단순화하면, `useMemo`는 이런 구조로 이해하시면 됩니다:

```js
// 개념적(의사코드) 예시
function useMemo(create, deps) {
  const hook = getCurrentHook(); // 이 컴포넌트의 N번째 훅 슬롯

  if (!hook.hasValue) {
    // 최초 렌더링
    const value = create();
    hook.memoizedState = [value, deps];
    hook.hasValue = true;
    return value;
  }

  const [prevValue, prevDeps] = hook.memoizedState;

  if (areDepsSame(prevDeps, deps)) {
    // 의존성이 동일 → 이전 값 재사용
    return prevValue;
  }

  // 의존성이 달라짐 → 함수 다시 실행
  const nextValue = create();
  hook.memoizedState = [nextValue, deps];
  return nextValue;
}
```

* 각 훅(`useState`, `useEffect`, `useMemo` 등)은
  **현재 렌더링 중인 컴포넌트 + 훅 호출 순서**로 “슬롯”을 배정받음
* `useMemo`의 `memoizedState`에는
  ` [저장된 값, 의존성 배열]` 같은 구조로 값이 저장되어 있다고 생각하면 됩니다.

**중요 포인트**

* `deps` 비교는 **얕은 비교(shallow)**
  → 배열 길이 같고, 각 요소를 `Object.is`로 비교
* `deps`를 제공하지 않으면?

  * `useMemo(fn)` → **의존성 배열 생략은 비추천** (렌더마다 실행과 거의 동일)
  * 공식 문서에서도 보통 **항상 deps를 제대로 넣는 것**을 권장

---

## 6. useMemo vs useCallback 🤝

둘은 사실 **본질적으로 같은 훅**입니다.

* `useMemo`는 **값(value)**을 메모이제이션
* `useCallback`은 **함수(function)**을 메모이제이션

실제로는 이런 식으로 생각해도 큰 무리가 없습니다:

```js
// 개념적으로
useCallback(fn, deps) === useMemo(() => fn, deps);
```

| 훅           | 메모이제이션 대상             | 사용 예시                                  |
| ----------- | --------------------- | -------------------------------------- |
| useMemo     | 값 (숫자, 문자열, 객체, 배열 등) | 비싼 계산 결과, 정렬/필터링된 배열, 스타일 객체 등         |
| useCallback | 함수                    | 자식에게 넘기는 핸들러, `useEffect` 의존성에 쓰일 함수 등 |

---

## 7. useMemo vs React.memo 🧱

이 둘도 자주 헷갈립니다.

* `useMemo`

  * **컴포넌트 내부**에서 사용
  * “값(계산 결과)”를 캐시
* `React.memo`

  * **컴포넌트 밖에서** 사용
  * “컴포넌트 함수”의 렌더링 자체를 메모이제이션

```tsx
// 자식 컴포넌트
const Child = React.memo(function Child({ value }) {
  console.log("🔄 Child 렌더링");
  return <div>{value}</div>;
});

// 부모 컴포넌트
function Parent({ x }) {
  const computed = useMemo(() => heavy(x), [x]);
  return <Child value={computed} />;
}
```

* `useMemo`는 `computed` 값을 캐시
* `React.memo`는 `Child` 컴포넌트의 **렌더링 자체**를 캐시

  * `props.value`가 이전과 같다면 렌더링 스킵

실무에서는 종종 **둘을 함께** 사용합니다.

---

## 8. useMemo 오용 & 주의할 점 ⚠️

### 8-1. “무조건 쓰면 성능이 좋아진다” ❌

* `useMemo` 자체도 **비용이 있습니다**.

  * deps 비교, 훅 관리, 메모리 사용 등
* 계산이 가벼운데 `useMemo`만 덕지덕지 붙이면:

  * 코드 복잡도만 증가
  * 성능은 거의 차이 없음

**가이드라인 (감각적인 기준)**

* O(1) ~ O(n) 정도의 가벼운 계산 → 보통 그냥 냅둬도 됨
* 매 렌더마다 의미 있게 무거운 계산 (정렬, 큰 배열, 복잡한 연산 등) → `useMemo` 고려
* 성능 이슈가 **실제로** 발생했을 때,

  * 프로파일링 후 **핫스팟 지점에만** 신중하게 적용하는 것이 좋습니다.

---

### 8-2. 부수 효과(side effect)를 넣으면 안 된다 🚫

```tsx
// ⛔ 나쁜 예시
const value = useMemo(() => {
  fetch("/api/user");       // 부수 효과
  console.log("로그...");    // 부수 효과
  return something;
}, [deps]);
```

* `useMemo`는 **“렌더링 중에 실행되는 함수”**입니다.
* 렌더링 중에는 **“순수하게 계산만”** 해야 하고,
* 외부 세계와 상호작용 (`fetch`, DOM 조작, `setState`)은 하면 안 됩니다.

이런 건 `useEffect`로 분리해야 합니다.

---

### 8-3. 의존성 배열(deps)을 잘못 작성하면 버그 위험 💥

```tsx
// ⛔ count를 빼 먹은 경우
const doubled = useMemo(() => count * 2, []);  // deps 빠짐
```

* `count`가 바뀌어도 `doubled`는 **처음 값 그대로** 유지 → 논리적인 버그
* ESLint의 `react-hooks/exhaustive-deps` 규칙을 **꼭** 사용하는 이유입니다.

**원칙**

* `create` 함수에서 사용하는 외부 변수는

  * **모두 deps 배열에 넣는 것이 기본**
* 일부러 빼고 싶으면

  * 그 이유를 아주 명확히 알고 있어야 합니다 (매우 예외적인 경우)

---

## 9. 작은 데모들로 감각 잡기 🎯

### 9-1. “비싼 계산” 데모

```tsx
import { useMemo, useState } from "react";

function fibonacci(n: number): number {
  console.log("🧮 fib 계산중...", n);
  if (n <= 1) return n;
  return fibonacci(n - 1) + fibonacci(n - 2);
}

export default function FibDemo() {
  const [n, setN] = useState(10);
  const [count, setCount] = useState(0);

  const fibN = useMemo(() => fibonacci(n), [n]);

  return (
    <div>
      <h2>useMemo Fibonacci 데모</h2>
      <p>n = {n}</p>
      <button onClick={() => setN((prev) => prev + 1)}>n 증가</button>

      <p>
        fib({n}) = {fibN}
      </p>

      <hr />

      <p>다른 state: {count}</p>
      <button onClick={() => setCount((c) => c + 1)}>count 증가</button>
    </div>
  );
}
```

* `count`만 바뀌면?

  * `FibDemo`는 다시 렌더링되지만
  * `fibN`은 **재계산되지 않음** (콘솔 로그를 보면 확인 가능)
* `n`이 바뀔 때만 `fibonacci`가 다시 호출됨

---

### 9-2. React.memo와 조합해서 자식 최적화

```tsx
const UserListItem = React.memo(function UserListItem({ user }) {
  console.log("👤 User 렌더링:", user.name);
  return <li>{user.name}</li>;
});

function UserList({ users }) {
  // ⚠️ 아래처럼 쓰면 매 렌더마다 새 배열 생성
  // const activeUsers = users.filter((u) => u.isActive);

  // ✅ useMemo로 참조 고정
  const activeUsers = useMemo(
    () => users.filter((u) => u.isActive),
    [users]
  );

  return (
    <ul>
      {activeUsers.map((u) => (
        <UserListItem key={u.id} user={u} />
      ))}
    </ul>
  );
}
```

* `users`가 안 바뀌면 `activeUsers` 배열도 **참조 동일** 유지
* `UserListItem`은 `React.memo` 덕분에 **불필요한 렌더링 스킵**

---

### 9-3. useEffect 의존성에서 객체 안정화

```tsx
function Logger({ filter }) {
  const config = useMemo(
    () => ({
      level: "debug",
      filter, // prop
    }),
    [filter]
  );

  useEffect(() => {
    console.log("📜 로그 설정 변경:", config);
  }, [config]);

  return <div>로그 설정: {config.level}</div>;
}
```

* `filter`가 바뀔 때만 `config` 참조가 바뀌고
* 그때만 `useEffect`가 실행됩니다.

---

## 10. 정리 – 언제 useMemo를 쓰면 좋은가? ✅

**1️⃣ 꼭 써볼 만한 경우**

* 진짜로 **비싼 계산(heavy computation)** 이 있고,
* 그 계산의 입력이 자주 바뀌지 않는데,
* 컴포넌트가 자주 렌더링되는 상황
* 정렬/필터링 등 큰 배열에 대한 연산
* 객체/배열을 만들어서

  * `React.memo` 자식에 props로 넘겨야 할 때
  * `useEffect`, `useCallback`의 의존성에서 안정적인 참조가 필요할 때

**2️⃣ 굳이 안 써도 되는 경우**

* 계산 자체가 매우 가벼운 경우
* 렌더링 빈도도 낮은데 습관처럼 붙이는 경우
* “그냥 쓰면 성능 좋아지겠지?” 수준의 **조기 최적화**

**3️⃣ 항상 기억할 것**

* `useMemo`의 콜백은 “렌더링 과정”에서 실행된다 → **순수 함수만**
* 부수 효과는 `useEffect`로
* `deps` 배열은 ESLint 추천대로 **성실하게** 채워넣기


