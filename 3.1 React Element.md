# 🔥 리액트 엘리먼트(React Element)

## — JSX의 본질, Virtual DOM의 최소 단위, 렌더링의 핵심을 모두 파헤치기 🚀

리액트 앱을 구성하는 가장 작은 단위는 **컴포넌트(Component)** 가 아니라, 바로 **엘리먼트(Element)** 입니다.
리액트에서 **돔(DOM)을 설명하는 객체**, 그리고 **렌더링의 최소 단위**는 바로 엘리먼트입니다.

이 글에서는 다음 내용을 아주 깊이 있게 다룹니다:

* ✔ React Element란 무엇인가
* ✔ 일반 DOM 노드와의 차이
* ✔ JSX가 어떻게 Element로 변환되는가
* ✔ Element의 불변성(Immutable)
* ✔ Element 트리 구조
* ✔ Virtual DOM과 Element의 관계
* ✔ 렌더링 과정에서 Element가 어떤 역할을 하는가
* ✔ 컴포넌트와 Element의 본질적 차이
* ✔ createElement와 JSX 분석

---

# 1️⃣ React Element란 무엇인가?

## 📌 “화면에 어떻게 그려져야 할지”를 표현하는 **객체(Object)**

리액트 엘리먼트는 **UI를 어떻게 보여줄지 명세하는 ‘단순한 자바스크립트 객체’** 입니다.

예를 들어 JSX로 다음과 같이 작성한다고 합시다.

```jsx
const element = <h1 className="title">Hello World</h1>;
```

이 코드는 실제로 *다음과 같은 자바스크립트 객체*로 변환됩니다:

```js
const element = {
  type: 'h1',
  props: {
    className: 'title',
    children: 'Hello World'
  }
};
```

즉, 엘리먼트는:

* 실제 DOM 노드가 아니다 ❌
* 오직 “어떻게 생겼는지” 설명한 기록이다 📄
* 렌더러(react-dom)가 이 객체를 이용해 DOM을 조작한다 🏗️

👉 **결론:**
React Element = 화면 구조를 설명하는 *순수한 데이터 객체*

---

# 2️⃣ DOM Node와 React Element의 차이 🤔

| 구분    | DOM Node             | React Element                  |
| ----- | -------------------- | ------------------------------ |
| 정체    | 브라우저가 메모리에 만드는 진짜 노드 | UI 구조를 설명하는 POJO(Plain Object) |
| 변화    | mutable (수정 가능)      | immutable (불변)                 |
| 생성 비용 | 비쌈                   | 매우 저렴                          |
| 목적    | 실질적 렌더링              | 렌더링을 위한 설계도                    |

DOM 노드는 만들기만 해도 브라우저가 메모리와 렌더 트리를 갱신해야 해서 비용이 큽니다.
반면 React Element는 단순한 객체라 생성 비용이 거의 없습니다.

---

# 3️⃣ JSX → React Element 변환 과정 🛠️

## JSX는 단지 Syntactic Sugar 🍬

JSX는 결국 다음 함수 호출로 변환됩니다:

```jsx
<h1 id="title">Hello</h1>
```

➡ Babel 변환 결과:

```js
React.createElement("h1", { id: "title" }, "Hello");
```

React.createElement가 반환하는 값이 바로 **React Element 객체**입니다.

### ✔ React.createElement의 반환값 구조

```js
{
  $$typeof: Symbol(react.element),
  type: "h1",
  key: null,
  ref: null,
  props: {
    id: "title",
    children: "Hello"
  },
  _owner: null,
}
```

여기서 중요한 필드:

* **type**: 태그 이름 또는 컴포넌트 함수/클래스
* **props**: 속성 + children
* **key**: 리스트 렌더링에서 비교용
* **ref**: DOM 접근용

---

# 4️⃣ 엘리먼트는 **불변(Immutable)** 이다 🔒

리액트 엘리먼트는 **절대 변경되지 않습니다.**

```js
element.props.title = "New Title"; // ❌ 불가능 (의미 없음)
```

왜 이렇게 설계되었을까?

## 💡 엘리먼트의 불변성 이유

1. **Virtual DOM 비교를 간단하게 만들기 위해**

   * 변경되면 새 객체를 다시 만들면 된다.
2. **렌더링 예측 가능성 증가**
3. **불필요한 DOM 업데이트 최소화**

결국 리액트에서 화면이 변경되려면:

* 새로운 엘리먼트를 생성해야 한다
* 현재 트리와 비교(diff) 후 필요한 DOM만 업데이트한다

---

# 5️⃣ 엘리먼트 트리(Element Tree) 구조 🌳

리액트 앱은 거대한 **엘리먼트 트리**입니다.
예:

```jsx
<App>
  <Header />
  <Main>
    <Sidebar />
    <Content />
  </Main>
</App>
```

이는 내부적으로 다음과 같은 객체 트리가 됩니다:

```
App Element
 ┣ Header Element
 ┗ Main Element
     ┣ Sidebar Element
     ┗ Content Element
```

이 트리는 Virtual DOM의 기반이 됩니다.

---

# 6️⃣ React Element vs Component 🤯

수강생들이 가장 헷갈리는 부분!

## ✔ Component는 "UI를 만드는 함수/클래스"

```jsx
function Header() {
  return <h1>Hello</h1>;
}
```

## ✔ Element는 "컴포넌트 실행 결과로 만들어지는 객체"

즉,

| 컴포넌트      | 엘리먼트                |
| --------- | ------------------- |
| 함수 또는 클래스 | 컴포넌트 호출 결과로 생성되는 객체 |
| 재사용 가능    | 재사용 불가능             |
| 로직 포함 가능  | 오직 UI 정보만 포함        |
| props 받음  | props 값을 기록         |

React는 렌더 시 ‘컴포넌트 → 엘리먼트’ 변환을 수행합니다.

---

# 7️⃣ 렌더링 과정 🔄

ReactDOM.createRoot().render()는 엘리먼트를 받아 작업을 시작합니다.

예:

```jsx
const root = ReactDOM.createRoot(document.getElementById("root"));
root.render(<App />);
```

실제 수행:

1. `<App />` → App Component 실행
2. App이 반환한 Element Tree 생성
3. 이전 엘리먼트 트리(old tree)와 비교(diff)
4. 변화된 부분만 실제 DOM 업데이트
5. UI 변경 완료

결국 **렌더링의 핵심 단위는 Element**다.

---

# 8️⃣ React.createElement 깊이 이해하기 🔍

다음 코드를 보자:

```jsx
<Card title="Profile">
  <UserProfile />
  <ActionButtons />
</Card>
```

이는 다음 객체로 변환된다:

```js
React.createElement(
  Card,
  { title: "Profile" },
  [
    React.createElement(UserProfile, null),
    React.createElement(ActionButtons, null)
  ]
);
```

여기서 중요한 포인트:

* `"Profile"` → 명시적 props
* `<UserProfile />`, `<ActionButtons />` → children props로 전달
* children은 **암묵적 props**임
* Card 컴포넌트는 다음처럼 children을 받는다:

```js
function Card({ title, children }) {
  ...
}
```

---

# 9️⃣ Virtual DOM과 React Element의 관계 🔗

Virtual DOM의 본질이 바로 **Element Tree**입니다.

* Virtual DOM: Element 객체들의 트리
* React는 매 렌더링 때 새로운 Element 트리를 생성
* 이전 트리와 비교하여 최소 변경만 DOM에 반영

즉, **Element = Virtual DOM 단위**.

---

# 🔟 정리: React Element 한 눈에 보기 👀

| 요소        | 설명                                       |
| --------- | ---------------------------------------- |
| 정체        | UI 구조를 기술한 자바스크립트 객체                     |
| 생성 방식     | JSX → Babel → createElement()            |
| 불변성       | Immutable                                |
| 역할        | Virtual DOM 구성                           |
| 렌더링       | ReactDOM이 Element 트리를 받아 diff 후 DOM 업데이트 |
| 컴포넌트와의 관계 | 컴포넌트 실행 결과물이 Element                     |

---

# 🏁 마무리: 왜 Element를 깊게 이해해야 하나? 🎓

리액트 렌더링을 정확히 이해하려면 다음 두 가지를 알아야 합니다:

1. **"컴포넌트는 엘리먼트를 반환한다"**
2. **"엘리먼트 트리가 실제 DOM 생성의 기반이다"**

이 두 개념을 정확히 이해하면 리액트의 대부분 메커니즘이 자연스럽게 풀립니다:

* 렌더링 최적화
* key의 역할
* 불변성
* Virtual DOM 비교
* children 패턴
* 컴포넌트 구조 설계

모두 React Element에서 시작됩니다.


