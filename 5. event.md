# 1. DOM 이벤트란 무엇인가? 🧩

DOM 이벤트는 이런 상황에서 발생합니다:

* 사용자가 버튼을 클릭했다 👉 `click` 이벤트
* 키보드를 눌렀다 👉 `keydown`, `keyup`
* 입력창에 글자를 입력했다 👉 `input`
* 폼을 전송하려 했다 👉 `submit`
* 스크롤을 내렸다 👉 `scroll`
* 마우스를 올려두었다 👉 `mouseover`
* 네트워크 상태가 바뀌었다 👉 `online` / `offline`
* DOM이 로드되었다 👉 `DOMContentLoaded`

**이벤트 시스템의 역할**:

1. 브라우저(UI 시스템)가 “어떤 일”이 발생했는지 보고한다.
2. DOM 트리에서 **어떤 노드에서 일어난 일인지**를 명확히 한다.
3. 그 노드(와 조상 노드들)에 등록된 **이벤트 리스너 함수들을 순서대로 호출**한다.

> 즉, “어떤 노드에서 어떤 타입의 사건이 발생했다 → 등록된 핸들러 호출”
> 이 전체 프로세스가 DOM 이벤트 시스템입니다.

---

# 2. 이벤트 흐름: 캡처링 → 타깃 → 버블링 🌊

DOM 이벤트는 단순히 :
“클릭된 요소의 핸들러만 호출” 이런 식으로 끝나지 않습니다.

**3단계 흐름(Phase)**를 갖습니다:

1. **캡처링 단계 (capturing phase)**

   * `window` → `document` → `<html>` → `<body>` → … → **타깃 요소까지 내려가면서**
   * `capture: true` 로 등록된 리스너들이 호출됩니다.

2. **타깃 단계 (target phase)**

   * 실제 이벤트가 일어난 요소에서의 처리.
   * 이때, 캡처/버블 모두의 리스너가 호출될 수 있습니다.

3. **버블링 단계 (bubbling phase)**

   * 타깃 요소 → 그 부모 → 그 부모 … → `<body>` → `<html>` → `document` 순으로 **위로 올라가며**
   * 일반(버블링) 리스너들이 호출됩니다.

대략 이런 느낌의 흐름입니다:

```text
window
  ↓ (capturing)
document
  ↓
<html>
  ↓
<body>
  ↓
<div id="outer">
  ↓
<button id="inner">여기 클릭!</button>  ← target
  ↑
<div id="outer">
  ↑ (bubbling)
<body>
<html>
document
```

이 덕분에 **부모 요소가 자식 요소의 이벤트를 “위임”받아서 처리**할 수 있게 됩니다. (→ 이벤트 위임, 아래에서 설명)

---

# 3. 이벤트 객체(Event)와 핵심 프로퍼티들 📦

이벤트가 발생하면 브라우저는 **이벤트 객체**(Event 인스턴스)를 만들어 리스너에 넘겨줍니다.

```js
button.addEventListener('click', function (event) {
  console.log(event.type);        // "click"
  console.log(event.target);      // 실제 클릭된 요소
  console.log(event.currentTarget); // 이 핸들러가 붙어 있는 요소
});
```

주요 프로퍼티들:

* `event.type`

  * `"click"`, `"input"`, `"submit"` 같은 이벤트 타입 문자열

* `event.target`

  * **실제 사건이 발생한 DOM 노드**
  * 예: `span`을 클릭했는데, `button` 안에 있는 `span`이면 `target`은 `span`

* `event.currentTarget`

  * **현재 이 핸들러가 실행되고 있는 요소**
  * 버블링/캡처 과정에서 부모에도 핸들러가 붙어 있다면, 그 부모가 `currentTarget`
  * 이 때문에 핸들러 내부에서는 `this` 대신 `event.currentTarget` 사용을 권장

* `event.bubbles`

  * 이 이벤트가 버블링을 지원하는지(Boolean)

* `event.cancelable`

  * `event.preventDefault()`로 **기본 동작 취소가 가능한지**

* `event.timeStamp`

  * 이벤트 발생 시각(ms)

* `event.composedPath()`

  * 이벤트가 통과한 노드들의 경로 배열 (타깃 → 조상들)

이벤트 시스템을 깊이 이해하려면
👉 `target` vs `currentTarget` vs 버블링 개념이 특히 중요합니다.

---

# 4. 이벤트 리스너 등록 방식들 ✍️

DOM 이벤트 핸들러 등록 방식은 크게 3가지입니다.

## 4.1 HTML 속성(onclick 등) 방식 (비추) ❌

```html
<button onclick="alert('clicked!')">클릭</button>
```

* 장점: 간단, 데모용으로 편함
* 단점:

  * **HTML과 JS가 뒤섞임** → 유지보수 악몽
  * 한 이벤트 타입에 **하나의 핸들러만 가능**
  * 전역 스코프 오염 등 문제

실무에서는 거의 안 씁니다.

---

## 4.2 DOM 프로퍼티 방식 (element.onclick) 😐

```js
const btn = document.querySelector('#myBtn');

btn.onclick = function () {
  console.log('clicked');
};

btn.onclick = function () {
  console.log('덮어쓰기'); // 이전 핸들러를 덮어버림
};
```

* 한 타입당 **하나**만 설정 가능 (마지막 할당이 이김)
* 그래도 HTML 속성 방식보다는 낫지만, 한계가 큼

---

## 4.3 `addEventListener` 방식 (표준, 권장) ✅

```js
const btn = document.querySelector('#myBtn');

function handler1() {
  console.log('handler1');
}
function handler2() {
  console.log('handler2');
}

btn.addEventListener('click', handler1);
btn.addEventListener('click', handler2); // 둘 다 호출됨
```

장점:

1. 한 이벤트 타입에 **여러 개의 핸들러** 등록 가능
2. **캡처링/버블링, passive, once 등 옵션**을 정교하게 제어 가능
3. `removeEventListener`로 제거 가능

옵션 객체를 사용하는 예:

```js
btn.addEventListener(
  'click',
  handler1,
  {
    capture: false,  // 버블링 단계에서 실행(기본값)
    once: true,      // 한 번 실행 후 자동 제거
    passive: true    // preventDefault()를 호출하지 않겠다고 약속
  }
);
```

---

# 5. 이벤트 버블링과 캡처링, 그리고 전파 제어 🧬

## 5.1 기본 예제

HTML:

```html
<div id="outer">
  <button id="inner">클릭</button>
</div>
```

JS:

```js
const outer = document.getElementById('outer');
const inner = document.getElementById('inner');

outer.addEventListener('click', () => {
  console.log('outer 버블링');
});

inner.addEventListener('click', () => {
  console.log('inner 버블링');
});
```

버튼을 클릭하면 출력:

```text
inner 버블링
outer 버블링
```

이유:

1. 타깃: `#inner`에서 발생
2. 타깃 단계에서 `#inner` 핸들러 실행
3. 버블링 단계에서 부모 `#outer` 핸들러 실행

---

## 5.2 캡처링 핸들러 등록

```js
outer.addEventListener(
  'click',
  () => {
    console.log('outer 캡처');
  },
  { capture: true }
);
```

이제 버튼 클릭 시:

```text
outer 캡처
inner 버블링
outer 버블링
```

* `capture: true` → 캡처링 단계에서 실행
* 기본(혹은 `{ capture: false }`) → 버블링 단계에서 실행

---

## 5.3 이벤트 전파 멈추기: `stopPropagation` / `stopImmediatePropagation` ⛔

### `event.stopPropagation()`

이벤트가 **더 이상 상위로 전파되지 않도록** 합니다.

```js
inner.addEventListener('click', (event) => {
  console.log('inner 버블링');
  event.stopPropagation(); // 여기서 끝
});

outer.addEventListener('click', () => {
  console.log('outer 버블링'); // 호출되지 않음
});
```

### `event.stopImmediatePropagation()`

* 동일한 노드에 **여러 핸들러가 등록된 경우**, 현재 핸들러 이후의 핸들러도 실행되지 않게 막음.

```js
inner.addEventListener('click', (e) => {
  console.log('A');
  e.stopImmediatePropagation();
});

inner.addEventListener('click', () => {
  console.log('B'); // 실행 안 됨
});
```

---

# 6. 기본 동작과 `preventDefault()` 🛑

많은 이벤트에는 브라우저의 **“기본 동작(Default Action)”**이 있습니다.

예:

* `<a href="...">` 클릭 → 해당 주소로 이동
* `<form>` `submit` → 서버로 폼 데이터 전송 및 페이지 리로드
* 오른쪽 클릭 → 컨텍스트 메뉴 표시
* 텍스트 드래그 → 선택 표시

이 기본 동작을 막고 싶을 때:

```js
const link = document.querySelector('a#no-nav');

link.addEventListener('click', (event) => {
  event.preventDefault(); // 기본 동작 취소
  console.log('링크 클릭, 하지만 페이지 이동은 막음');
});
```

주의:

* `event.cancelable === true` 인 이벤트에서만 의미가 있음.
* `passive: true` 리스너에서는 `preventDefault()`를 호출하면 **경고**가 뜹니다 (스크롤 최적화 관련).

```js
window.addEventListener(
  'touchmove',
  (e) => {
    // e.preventDefault();  // passive:true면 이건 금지
  },
  { passive: true }
);
```

---

# 7. 이벤트 위임(Event Delegation) 🚦

**이벤트 위임**은 DOM 이벤트 버블링을 이용한, 성능/유지보수 최적화 테크닉입니다.

상황:

* `<ul>` 안에 `<li>` 1,000개가 있고, 각각을 클릭했을 때 핸들링을 하고 싶다.
* 모든 `<li>`에 각각 `addEventListener`를 붙이면 **비효율적**.

해결: 부모 요소 하나에만 리스너를 달고, **`event.target`을 보고 분기**합니다.

```html
<ul id="menu">
  <li data-id="1">Home</li>
  <li data-id="2">About</li>
  <li data-id="3">Contact</li>
</ul>
```

```js
const menu = document.getElementById('menu');

menu.addEventListener('click', (event) => {
  const li = event.target.closest('li'); // 가장 가까운 li 찾기
  if (!li || !menu.contains(li)) return; // ul 밖 클릭 무시

  const id = li.dataset.id;
  console.log(`메뉴 ${id} 클릭됨`);

  // 여기서 id에 따라 분기 처리
});
```

장점:

* 동적으로 `<li>`를 추가해도 **이벤트 핸들러를 다시 붙일 필요 없음**
* 메모리 절약 + 코드 단순화
* SPA 프레임워크(React 이전 시대)에선 필수 패턴이었습니다.

---

# 8. 주요 DOM 이벤트 타입들 요약 📚

모두 다 외울 필요는 없고, **주로 쓰는 것들을 그룹별로 이해**하시면 됩니다.

## 8.1 마우스 / 포인터 관련 🖱️

* `click` : 클릭 (보통 `mousedown` + `mouseup` 조합 이후)
* `dblclick` : 더블클릭
* `mousedown`, `mouseup`
* `mousemove`
* `mouseenter`, `mouseleave` (버블링 X)
* `mouseover`, `mouseout` (버블링 O)
* `contextmenu` : 오른쪽 클릭 메뉴

추가로, 모바일/펜 등을 통합한 **Pointer Events** (`pointerdown`, `pointerup`, …) 도 있습니다.

---

## 8.2 키보드 관련 ⌨️

* `keydown` : 키가 눌리는 순간
* `keyup` : 키에서 손 뗄 때
* 옛날에는 `keypress`도 있었지만, 지금은 거의 사용 안 함 (deprecated 흐름)

이벤트 객체:

* `event.key` : `"a"`, `"Enter"`, `"Escape"` 등
* `event.code` : `"KeyA"`, `"Enter"`, `"Escape"` 등 (키보드 물리 위치 기준)
* `event.altKey`, `event.ctrlKey`, `event.shiftKey`, `event.metaKey`

---

## 8.3 입력 / 폼 관련 📝

* `input` : `<input>`, `<textarea>` 값이 바뀔 때마다 (실시간)
* `change` : 값 변경 후 **포커스가 빠져나갈 때** 등
* `submit` : `<form>` 제출 시
* `focus`, `blur` (버블링 X)
* `focusin`, `focusout` (버블링 O)

예:

```js
const input = document.querySelector('#username');

input.addEventListener('input', (e) => {
  console.log('실시간 값:', e.target.value);
});
```

---

## 8.4 문서 로드 / 라이프사이클 관련 📂

* `DOMContentLoaded` : HTML 파싱 완료 후, DOM 트리 준비 완료
  → 이미지/스타일 완전 로딩과는 무관
* `load` : 모든 리소스(이미지, CSS 등 포함) 로딩 완료
* `beforeunload` : 페이지 떠나기 직전
* `visibilitychange` : 탭이 숨김/표시 상태로 변경될 때

---

## 8.5 기타

* `scroll`
* `resize`
* `hashchange`
* `online` / `offline`
* `dragstart`, `dragover`, `drop` … (Drag & Drop API)
* `copy`, `paste`, `cut` (클립보드)

실제 개발에서는 프레임워크(React, Vue 등)가 이 이벤트들을 래핑해서 사용하지만, **근본은 전부 DOM 이벤트 시스템**입니다.

---

# 9. 브라우저 이벤트 루프와 DOM 이벤트의 관계 🧠

DOM 이벤트는 브라우저의 **이벤트 루프 시스템**과 맞물려 작동합니다.

1. 사용자가 클릭 → 브라우저 UI 스레드가 “click 발생”을 감지
2. 브라우저가 해당 DOM 노드를 찾고 이벤트 객체 생성
3. **JS 실행 컨텍스트(Call Stack)**가 비어 있는 시점에,
   “`click` 이벤트 처리 작업”을 큐에 넣고 실행
4. 이벤트 리스너 내부의 JS가 **동기적으로** 실행
5. 리스너 내부에서 `Promise`를 만들면?
   → `then` 콜백은 **마이크로태스크 큐**에서 이후 실행

중요 포인트:

* “이벤트 핸들러 호출 자체”는 **동기**입니다.

  * `click`이 발생하면 그 핸들러는 중간에 끼어들어 실행됨
* 하지만 전체적으로 보면,

  * “이벤트 발생 → 태스크 큐에 작업으로 들어감 → 콜스택이 비었을 때 처리” 구조라 비동기처럼 보이는 것

DOM 이벤트를 깊이 이해하려면:

* 콜 스택
* 태스크 큐 / 마이크로태스크 큐
* 이벤트 루프

와 함께 바라보는 것이 중요합니다. (이 부분은 이미 따로 깊게 보셨으니, 여기서는 개략만 적겠습니다. 😉)

---

# 10. 커스텀 이벤트: `CustomEvent`와 `dispatchEvent()` 🧪

DOM 이벤트 시스템은 사용자 정의 이벤트에도 쓸 수 있습니다.

```js
const box = document.getElementById('box');

// 커스텀 이벤트 리스너
box.addEventListener('highlight', (event) => {
  console.log('highlight 이벤트 발생!', event.detail);
});

// 커스텀 이벤트 생성
const evt = new CustomEvent('highlight', {
  detail: { color: 'yellow', duration: 500 },
  bubbles: true,      // 버블링 여부
  cancelable: true    // preventDefault 가능 여부
});

// 이벤트 발행
box.dispatchEvent(evt);
```

* `detail` 객체에 원하는 데이터를 넣어서 전달
* 일반 DOM 이벤트와 똑같이 **캡처링 → 타깃 → 버블링** 흐름을 탐
* 컴포넌트 간 통신 등에도 활용할 수 있음 (단, 요즘은 프레임워크/상태 관리로 대체되는 경우 많음)

---

# 11. DOM 이벤트 다룰 때 자주 하는 실수 & 베스트 프랙티스 ✅

## (1) `this` vs `event.target` vs `event.currentTarget` 혼동

* `this` : 전통적인 핸들러에서 `currentTarget`과 같지만, 화살표 함수에서는 다름
* `event.target` : 실제 이벤트가 발생한 곳 (가장 안쪽 노드)
* `event.currentTarget` : 핸들러가 **붙어 있는** 요소

**추천**: 항상 `event.currentTarget`을 사용하는 습관을 들이시면 안정적입니다.

---

## (2) 버블링/캡처링을 제대로 몰라서 예측 못 하는 동작 🤯

* 부모/자식 모두에 핸들러가 있을 때 호출 순서가 헷갈림
* `stopPropagation()`을 남발하면서 디버깅 지옥…

**팁**:

* 디버깅할 때는 콘솔에

  ```js
  console.log('phase', event.eventPhase, 'target', event.target, 'currentTarget', event.currentTarget);
  ```

  등을 찍어 보시면 흐름이 한눈에 들어옵니다.

---

## (3) HTML 속성 핸들러(onclick, onsubmit 등) 사용

* 작은 데모나 튜토리얼을 제외하면 피하는 것이 좋습니다.
* **뷰와 로직을 분리**하는 것이 유지보수의 핵심입니다.

---

## (4) 성능 상 문제: 많은 요소에 개별 핸들러 등록

* 리스트가 큰 상황에서 각 요소에 리스너를 붙이면 메모리와 성능 문제
* → **이벤트 위임**으로 해결

---

## (5) `preventDefault`와 `stopPropagation` 혼동

* `preventDefault()` : **브라우저의 기본 동작만** 막음
  (링크 이동, 폼 전송 등)
* `stopPropagation()` : **이벤트가 상위로 전파되는 것**만 막음

둘은 전혀 다른 역할입니다.

---

# 12. 마무리 정리 🧾

DOM 이벤트는 단순 “클릭하면 함수 실행” 수준이 아니라:

1. **DOM 트리 전체를 타고 내려갔다 올라오는 3단계 흐름** (캡처 → 타깃 → 버블링)
2. `Event` 객체를 통한 **풍부한 메타데이터 제공**
3. `addEventListener`의 **다양한 옵션**(capture, once, passive 등)
4. **이벤트 위임, 기본 동작 차단, 전파 제어** 등의 고급 패턴
5. 브라우저 **이벤트 루프, 콜스택, 큐 시스템**과의 협력 구조

까지 포함하는 꽤 잘 설계된 시스템입니다. 💡

