> **번들러는 서로 다른 JS 모듈 파일들을 하나로 합치는 과정에서
> ESM/CJS 모듈 시스템을 제거하고, 하나의 즉시 실행 가능한 스크립트로 변환합니다.** 

그래서 번들된 코드에는:

* `import` 없음
* `export` 없음
* 모듈 경계 없음
* 파일 구분 없음
* 모든 함수와 변수가 번들러가 만든 하나의 스코프 안에 들어감

---

# 📦 왜 번들 후에는 import/export가 사라질까?

## 이유 1) **모듈 시스템이 필요 없어진다**

원래는:

* `math.js`는 독립된 모듈이다
* `app.js`는 math.js를 가져와야 한다

그래서 import/export 문법이 필요합니다.

하지만 번들러는 이를 다음처럼 바꿉니다.

```
math.js + app.js → 하나의 JS 파일(bundle.js)
```

➡ 이 시점에 "모듈 경계"가 없어지기 때문에
➡ 자연스럽게 import/export도 필요 없어집니다.

---

# 📌 번들링 과정(쉽게 설명)

## 🔹 Step 1: 의존성 그래프 분석

app.js → math.js

## 🔹 Step 2: math.js의 코드를 app.js 안으로 “인라인”

```js
function add(a, b) { return a + b; }
console.log(add(2,3));
```

## 🔹 Step 3: import/export 제거

이미 math.js 코드가 통째로 포함되었기 때문에
import/export는 “불필요한 문장”이라 제거함.

즉, 최종 번들에서는
모듈 로더(Module Loader) 역할을 하는 문장이 필요 없음.

---

# ✔ 이유 2) 브라우저는 오래된 ES5만 이해해도 실행 가능하게 하기 위함

브라우저는 기본적으로 다음과 같은 고급 기능을 원래 이해하지 못했습니다.

* import/export (ESM)
* async/await
* JSX
* TypeScript
* 모듈 스코프

그러나 번들된 bundle.js는 이런 고급 문법을 모두 제거·변환한 결과물이므로

```js
function add(a,b){return a+b}
console.log(add(2,3));
```

브라우저는 ES5 기반이라도 이 코드를 전부 이해할 수 있습니다.

---

# ✔ 이유 3) import/export는 "런타임 기능"이 아니라 "정적 의존성"이기 때문

`import`는 단순히 기능이 아니라
**모듈 로딩 규칙을 포함한 언어 차원의 런타임 메커니즘**입니다.

하지만 번들러는 런타임이 아닌 **빌드 타임(static time)** 에 미리 의존성 구조를 분석합니다.

그래서:

* 실행하기 전(빌드 타임)에
* 필요한 모든 의존성을 찾아서
* 이미 코드 안에 합쳐 넣기 때문에

런타임 import가 필요 없어지는 것입니다.

---

# ✔ 이유 4) 하나의 파일이 되면 import/export가 동작할 이유가 없기 때문

예를 들어:

```js
export function add() {}
```

이라는 문장은 “이 기능을 외부에 공개한다”는 의미인데,

번들링 후에는 “외부 모듈”이라는 개념 자체가 없어지므로
export가 필요 없고 의미도 없습니다.

---

# ✔ 예제를 구조적으로 다시 설명하면

번들 전:

```
math.js (모듈1)
 └─ export add
app.js (모듈2)
 └─ import add
```

번들 후:

```
bundle.js
 └─ add 함수가 그냥 정의됨
 └─ app.js 로직이 이어서 실행됨
```

→ 모듈 시스템 자체가 제거됨
→ 하나의 큰 스크립트가 됨
→ “모듈 간 연결”이라는 개념 자체가 사라짐
→ 따라서 import/export 제거됨

---

# ⭐ 결론

> **번들링 후에는 import/export가 필요 없고,
> 번들러는 이 키워드를 제거하고 각 파일의 코드를 하나의 스크립트로 합쳐 넣습니다.**

> 즉, 번들링은 “하나의 실행 파일을 만들기 때문에
> 모듈 시스템이 의미가 없어지고 제거된다.”는 뜻입니다.

