리액트의 `useState`는 “리액트 Hook의 입구”이자, **함수 컴포넌트에 상태(state)를 붙여주는 핵심 Hook**입니다.
겉으로는 단순한 카운터 예제 하나면 설명 끝나는 것 같지만, 실제로는 **렌더링, Fiber, Hook 메모리 슬롯, 배칭, 비동기 업데이트**까지 다 연결된 개념입니다.⚛️✨

---

## 1. 왜 `useState`가 필요한가? – 상태(state)란 무엇인가 🤔

먼저 “상태(state)”부터 정리하겠습니다.

* **props**

  * 부모 컴포넌트가 자식에게 “넘겨주는 데이터”입니다.
  * 컴포넌트 입장에서는 **읽기 전용(read-only)** 입니다.
* **state**

  * 컴포넌트 “자기 자신이 소유한 데이터”입니다.
  * 컴포넌트 내부에서 **직접 변경(setState)** 할 수 있습니다.
* **일반 지역 변수(let / const)**

  * 함수가 다시 호출(render)될 때마다 **초기화**됩니다.
  * 렌더링 사이에 값을 “기억”하지 못합니다.

함수 컴포넌트는 그냥 자바스크립트 함수이기 때문에:

```js
function Counter() {
  let count = 0
  // ...
}
```

이렇게 하면 **매 렌더마다 `count`가 0으로 초기화**됩니다.
그래서 리액트는 “렌더링 사이에도 값을 기억할 수 있는 메커니즘”이 필요했고,
그게 바로 **`useState`로 연결되는 “Hook 메모리 슬롯 + Fiber 구조”** 입니다.

---

## 2. `useState`의 기본 사용법 🧩

가장 많이 보는 형태부터 보겠습니다.

```jsx
import { useState } from 'react';

function Counter() {
  const [count, setCount] = useState(0); // 매번 호출되지만 초기화는 한번만 합니다. Fiber 노드에 저장되어 있던 기존 상태값을 꺼내서 리턴합니다.

  const handleClick = () => {
    setCount(count + 1);
  };

  return (
    <button onClick={handleClick}>
      You clicked {count} times
    </button>
  );
}
```

여기서 중요한 포인트는:

1. `useState(초기값)`은 **배열을 리턴** 합니다.
2. **배열의 첫 번째 엘리먼트**: 현재 상태 값 (`count`)
3. **배열의 두 번째 엘리먼트**: 상태를 변경하는 함수 (`setCount`)
4. `setCount`를 호출하면 → React가 **이 컴포넌트를 다시 렌더링**합니다.
5. 다시 렌더링할 때 `useState`는 **이전에 저장해둔 상태 값**을 꺼내서 `count`에 넣어줍니다.

자바스크립트로 보면 시그니처는 대략 이렇게 생겼다고 볼 수 있습니다:

```
function useState(initialState) {
  // 실제 React 내부 로직을 단순화한 개념적 구조입니다.
  // 1. 초기값 설정 (함수면 실행해서 결과값 사용)
  let state = typeof initialState === 'function' ? initialState() : initialState;

  // 2. 상태 업데이트 함수
  const setState = (nextState) => {
    // 함수형 업데이트 처리 (prev => next)
    const valueToStore = typeof nextState === 'function' ? nextState(state) : nextState;
    
    // 이후 React의 리렌더링 프로세스 유발...
    state = valueToStore;
  };

  return [state, setState];
}
```

여기서 눈여겨볼 점:

* `initialState`가 **값이 될 수도 있고, 함수가 될 수도** 있습니다. (lazy init)
* `setState` 아규먼트도 **값 또는 이전 상태를 이용하는 함수**가 될 수 있습니다.

이 부분은 아래에서 더 자세히 보겠습니다. 👇

---

## 3. `useState`는 내부에서 어떻게 동작할까? 🧠 (Hook 메모리 슬롯 + Fiber)

조금 더 깊이 들어가 보겠습니다.
사용자 입장에서는 `useState` 한 줄이지만, 내부에서는 대략 이런 구조로 동작합니다.

### 3-1. 컴포넌트와 Fiber, 그리고 Hook 메모리 슬롯

React는 각각의 컴포넌트를 **Fiber 노드**로 관리합니다.

* `Counter` 컴포넌트가 하나 있으면 → `Counter`에 대응되는 **Fiber 노드**가 하나 생깁니다.
* 이 Fiber 노드안에는 **Hook들이 사용할 “연결 리스트(혹은 배열 같은 구조)”** 가 있고,
* `useState`, `useEffect` 등 Hook을 호출할 때마다 이 리스트에 순서대로 슬롯을 할당합니다.

즉, 이런 코드가 있을 때:

```jsx
function MyComponent() {
  const [a, setA] = useState(1);   // Hook 슬롯 #1
  const [b, setB] = useState(2);   // Hook 슬롯 #2
  const [c, setC] = useState(3);   // Hook 슬롯 #3
  // ...
}
```

React 입장에서는:

* 첫 번째 `useState` 호출 → “슬롯 #1”에 상태 저장
* 두 번째 `useState` 호출 → “슬롯 #2”에 상태 저장
* 세 번째 `useState` 호출 → “슬롯 #3”에 상태 저장

그리고 렌더링이 다시 일어날 때도 **같은 순서로 `useState`가 호출되기 때문에**,
“슬롯 #1, #2, #3”에 담아둔 상태를 다시 각각 `a`, `b`, `c`에 돌려줄 수 있습니다.

👉 그래서 **“Hooks는 항상 컴포넌트 최상위에서, 조건문/반복문 안에서 호출하면 안 된다”** 라는 규칙이 생깁니다.

* 만약 렌더마다 Hook 호출 순서가 바뀌면 → “슬롯 번호”가 꼬여버립니다.
* 그래서 **Hook의 순서를 보장**하기 위해 “Rules of Hooks”가 존재합니다.

### 3-2. memoizedState란?

Fiber 구조 안에는 각 Hook 상태들을 저장하는 `memoizedState` 같은 필드가 존재합니다.

* `memoizedState`는 간단히 말해 **“이 Fiber가 마지막 렌더링에서 사용한 상태 값”** 을 의미합니다.
* `useState`는 이 `memoizedState`에 상태를 보관했다가,
  다음 렌더링에서 이것을 꺼내 `const [state] = useState(...)`에 할당해 줍니다.

정리하면:

> **컴포넌트 함수는 매 렌더 시마다 새로 호출되지만,
> 상태 값은 Fiber에 있는 Hook 메모리 슬롯(`memoizedState`)에 저장되어 계속 유지됩니다.**

---

## 4. setState는 왜 “비동기”처럼 보일까? 🕒 (배칭과 렌더링)

자주 헷갈리시는 부분입니다.

```jsx
const [count, setCount] = useState(0);

const handleClick = () => {
  setCount(count + 1);
  console.log(count); // 여기에 뭐가 찍힐까요?
};
```

대부분의 경우 콘솔에는 **“업데이트 이전 값”** 이 찍힙니다.
왜냐하면:

1. `setCount`를 호출하는 순간, React는 업데이트를 **“요청”** 만 합니다.
2. React는 여러 개의 `setState` 호출을 **배치(batching)** 로 묶어서 한 번에 렌더링하려고 합니다.
3. 그래서 현재 함수가 실행 중일 때는 여전히 “이전 렌더의 `count` 값”을 보고 있습니다.
4. 함수가 끝나고, React가 모든 업데이트를 모아 **새 렌더를 트리거**합니다.
5. 새 렌더가 수행될 때 비로소 `count`가 업데이트된 값으로 바뀐 상태로 컴포넌트 함수가 다시 실행됩니다.

그래서 `setCount` 직후에 바로 `console.log(count)`를 찍으면,
**아직 “이전 렌더링 기준의 state”**를 참조하고 있기 때문에 헷갈리게 됩니다.

> ✅ 정리: `setState`는 “즉시 상태 값을 바꾸는 함수”가 아니라,
> **“다음 렌더에 사용할 새 상태 값을 예약하는 함수”**입니다.

---

## 5. `setState`의 두 가지 패턴 🧮

`useState`로 상태를 업데이트할 때 두 가지 방법이 있습니다.

### 5-1. 값 직접 전달

```jsx
setCount(10); // 다음 렌더에서 count는 10이 됩니다.
```

이 방식은 간단하지만, **이전 상태 값(prev)을 기준으로 계산해야 할 때 주의**가 필요합니다.

예:

```jsx
// ❌ 잠재적 버그
setCount(count + 1);
setCount(count + 1);
setCount(count + 1);
```

위 코드는 “3 증가”를 의도했지만,
배칭과 이전 상태 사용 때문에 **1만 증가**할 수 있습니다(같은 `count` 기준에서 세 번 계산).

### 5-2. 함수형 업데이트(Functional Update)

이럴 때는 `setState`에 **함수**를 넘겨야 합니다.

```jsx
setCount((prev) => prev + 1);
setCount((prev) => prev + 1);
setCount((prev) => prev + 1);
```

이 형태는 각 호출마다 **가장 최신의 상태 값**을 `prev`로 넘겨받기 때문에
결과적으로 `count`가 3 증가합니다. ✅

> 📌 규칙
>
> * “이전 상태를 이용해서 새 상태를 계산”해야 할 때는
>   **무조건 함수형 업데이트를 사용하는 습관**을 들이시는 것이 좋습니다.

---

## 6. Lazy Initialization (초기값을 함수로 넘기는 이유) 🐢
질문자님의 지적이 매우 예리하십니다. 기존 설명은 **'함수 정의/생성'**과 **'함수 실행(호출)'**의 차이를 명확히 구분하지 않아 오해를 불러일으킬 수 있습니다.

리액트 내부의 **Fiber 노드 활용 방식**과 **자바스크립트의 평가 순서**를 반영하여 더 정확하고 명확하게 수정해 드립니다.

---

## 6. Lazy Initialization (상태 초기화 지연) 🐢

`useState`의 인자로 초기값을 전달할 때, **값**을 직접 넣는 방식과 **함수**를 넣는 방식에는 큰 차이가 있습니다.

### 1. 값을 직접 넘길 때 (문제 발생)

```jsx
// ❌ 리렌더링마다 무거운 계산이 실행됨
const [value] = useState(expensiveComputation());

```

* **동작 원리:** 자바스크립트는 `useState` 함수를 실행하기 전에 아규먼트로 들어온 `expensiveComputation()`을 **먼저 실행**해서 결과값을 만들어야 합니다.
* **문제점:** 컴포넌트가 리렌더링될 때마다 이 라인이 읽히면서 `expensiveComputation()`이 매번 실행됩니다. **React는 첫 렌더링 이후 이 값을 버리지만, 쓸데없이 이 함수 실행으로 인해 CPU 자원은 낭비된 후**입니다.

### 2. 함수 형태로 넘길 때 (Lazy Initialization)

```jsx
// ✅ 리렌더링 시 함수 실행을 건너뜀
const [value] = useState(() => expensiveComputation());

```

* **동작 원리:** `useState`에 값이 아닌 **함수 자체(껍데기)**를 넘깁니다.
* **React의 처리:** * **최초 렌더링:** React가 Fiber 노드를 처음 만들 때, 전달받은 함수를 **실행**하여 초기값을 구합니다.
* **리렌더링:** 컴포넌트 함수가 다시 실행되면서 `() => expensiveComputation()`이라는 함수 객체는 매번 생성되지만, **React는 이미 Fiber 노드에 상태값이 있는 것을 보고 이 함수를 호출(Call)하지 않고 무시합니다.**



---

### 💡 핵심 요약: 왜 성능상 유리한가요?

| 구분 | `useState(expensive())` | `useState(() => expensive())` |
| --- | --- | --- |
| **함수 객체 생성** | (함수 아님) | 매 렌더링마다 발생 (매우 가벼움) |
| **무거운 계산 실행** | **매 렌더링마다 발생** ⚠️ | **최초 렌더링 시 딱 1번**만 발생 ✅ |
| **비용 발생 지점** | 인자 전달을 위한 선행 실행 | React 내부에서의 선택적 실행 |

> **✅ 결론:**
> 초기화 비용이 큰 작업(예: 로컬 스토리지 접근, 복잡한 배열 조작 등)은 반드시 **`useState(() => 초기값)`** 형태로 작성하세요.
> "함수가 매번 정의되느냐"보다 **"함수 내부의 무거운 로직이 실행되느냐"** 가 성능의 핵심입니다.

---


## 7. 객체/배열 상태에서의 불변성 이슈 🧊

`useState`는 **상태를 “교체(replace)”** 합니다.
클래스 컴포넌트의 `this.setState`처럼 **자동 merge를 해주지 않습니다.**

```jsx
// 클래스 컴포넌트의 this.setState는 shallow merge
this.setState({ a: 1 }); // 기존 state의 다른 필드는 유지

// useState는 교체
setState({ a: 1 }); // 기존 state의 다른 필드는 사라질 수 있음
```

예를 들어, 객체를 상태로 두었을 때:

```jsx
const [user, setUser] = useState({ name: 'Tom', age: 20 });

// ❌ 나쁜 예 – 나머지 필드가 날아갈 수 있음
setUser({ name: 'Jerry' }); // age 필드는 사라짐
```

이럴 땐 **항상 spread 연산자를 사용하여 기존 상태를 복사한 후 변경**해야 합니다.

```jsx
// ✅ 좋은 예
setUser((prev) => ({
  ...prev,
  name: 'Jerry',
}));
```

배열도 마찬가지입니다.

```jsx
// ❌ 직접 변경 (mutate)
todos.push(newTodo);
setTodos(todos); // React는 변경을 감지하지 못할 수 있음

// ✅ 새로운 배열로 교체
setTodos((prev) => [...prev, newTodo]);
setTodos((prev) => prev.filter((todo) => todo.id !== id));
```

> 핵심: `useState`의 상태는 **불변(immutable)하게 다루고,
> 항상 “새로운 객체/배열”을 만들어서 교체**해야 합니다.

---

## 8. 여러 개의 `useState` vs 하나의 큰 상태 🌳

상태를 설계할 때 자주 하는 고민입니다.

```jsx
// 1) 분리된 상태들
const [name, setName] = useState('');
const [age, setAge] = useState(0);
const [address, setAddress] = useState('');

// 2) 하나의 객체 상태
const [user, setUser] = useState({ name: '', age: 0, address: '' });
```

### 어떤 방식이 좋을까요?

* **서로 강하게 연관된 값**(예: `x`, `y` 좌표, `firstName`, `lastName`)은
  하나의 객체로 관리하는 것이 자연스러운 경우가 많습니다.
* 하지만 **독립적인 값**이라면,
  상태를 **여러 개의 `useState`로 분리**하는 편이 코드가 더 명확합니다.

예를 들어, 폼 입력에서 각 필드마다 별도 핸들러를 쓰지 않으려면 객체로 묶는 편이 좋고,
복잡한 상태 전환 로직이 많아지면 `useReducer`로 옮겨가는 것도 좋은 선택입니다.

---

## 9. 실제 예제: 입력 폼과 토글 스위치 ✍️

### 9-1. 간단한 입력 폼

```jsx
import { useState } from 'react';

function LoginForm() {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');

  const handleSubmit = (e) => {
    e.preventDefault();
    console.log('로그인 시도:', { email, password });
  };

  return (
    <form onSubmit={handleSubmit}>
      <div>
        <label>
          이메일:
          <input
            value={email}
            onChange={(e) => setEmail(e.target.value)}
          />
        </label>
      </div>
      <div>
        <label>
          비밀번호:
          <input
            type="password"
            value={password}
            onChange={(e) => setPassword(e.target.value)}
          />
        </label>
      </div>
      <button type="submit">로그인</button>
    </form>
  );
}
```

여기서:

* `email`, `password`는 **Controlled Component 패턴**으로 관리됩니다.
* `<input>`의 `value`가 **항상 state에서 온다** → UI = f(state)
* 사용자가 입력을 바꾸면 `onChange` 핸들러가 `setState`를 호출 → **다시 렌더** → `value`가 갱신된 상태로 UI 반영

### 9-2. 토글 스위치

```jsx
function Toggle() {
  const [on, setOn] = useState(false);

  const toggle = () => {
    setOn((prev) => !prev); // 함수형 업데이트 사용
  };

  return (
    <button onClick={toggle}>
      {on ? 'ON 🔆' : 'OFF 🌑'}
    </button>
  );
}
```

* 상태가 boolean일 때는 이렇게 함수형 업데이트로 토글하는 패턴이 매우 흔합니다.
* 이전 상태(`prev`)에 의존하므로, 함수형 업데이트가 정석입니다.

---

## 10. `useState` vs `useReducer` 간단 비교 ⚔️

상태가 점점 복잡해지면, 다음과 같은 상황이 됩니다.

* 상태 필드가 많고
* 업데이트 로직도 IF/ELSE로 복잡하고
* 여러 이벤트에 따라 state를 여러 방식으로 변경해야 할 때

이럴 때는 `useState` 여러 개로 쪼개 쓰는 것보다,
**`useReducer`로 “상태 전이(reducer)”를 분리**하는 것이 코드 구조상 더 낫습니다.

* `useState`

  * 단순한 숫자/문자열/불린/간단한 객체/배열에 최적
* `useReducer`

  * **복잡한 상태 전이 로직**
  * 액션 타입별로 상태 업데이트를 정리하고 싶을 때

하지만 어떤 Hook을 쓰든, **기본 원리는 같습니다.**

* 상태는 Fiber에 저장된다.
* 렌더링 사이에 유지된다.
* 상태가 바뀌면 컴포넌트가 다시 렌더링된다.

---

## 11. 정리 🧾 – `useState`를 이해할 때 꼭 기억할 것들

마지막으로 핵심 포인트만 bullets로 정리해 보겠습니다.

1. `useState`는 함수 컴포넌트에 **상태를 붙여주는 Hook**입니다.
2. `const [state, setState] = useState(initial)` 형태로 사용합니다.
3. 상태 값은 **컴포넌트 함수 안의 지역 변수가 아니라**,
   Fiber에 있는 **Hook 메모리 슬롯(memoizedState)** 에 저장됩니다.
4. Hook은 **호출 순서**로 슬롯을 찾기 때문에,
   **조건문/반복문 안에서 호출하면 안 됩니다.**
5. `setState`는 **즉시 값을 바꾸는 것이 아니라**,
   **다음 렌더에 사용할 새 상태를 예약**하는 함수입니다. (배칭, 비동기처럼 보이는 이유)
6. 이전 상태에 의존해서 새 상태를 계산할 때는
   **항상 함수형 업데이트(`setState(prev => ...)`)** 를 사용하는 습관을 들이시는 것이 좋습니다.
7. `useState(() => heavyInit())` 형태로 쓰면 **초기화 비용이 큰 연산을 한 번만 수행**할 수 있습니다.
8. 객체/배열 상태는 **불변성 유지**가 필수입니다. 기존 상태를 직접 수정하지 말고,
   spread(`...`) 등을 사용하여 **새 객체/배열을 만들어 교체**해야 합니다.
9. 상태 구조가 복잡해지면 여러 `useState`로 나누거나 `useReducer`를 고려하시면 좋습니다.


