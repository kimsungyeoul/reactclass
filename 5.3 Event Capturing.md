리액트의 **Event Capturing**은 사실 “브라우저 캡처링” 위에 얹힌, 리액트만의 **합성 이벤트 시스템(Synthetic Event System)** 과 같이 이해해야 제대로 감이 옵니다.
아래에서는 👇

1. 브라우저의 캡처링 vs 버블링 간단 복습
2. 리액트 이벤트 시스템의 큰 그림
3. `onClickCapture` 같은 *Capture 핸들러*가 동작하는 정확한 순서
4. 버블링 핸들러(`onClick`)와 섞였을 때 이벤트 흐름
5. `stopPropagation`이 캡처링/버블링에 미치는 영향
6. React 17+에서의 이벤트 위임 위치 변화
7. 실전 패턴 & 주의사항

까지 정리해보겠습니다. 😎

---

## 1. 먼저, 브라우저의 기본 이벤트 흐름 🧠

DOM 이벤트는 세 단계로 흘러갑니다.

1. **Capturing Phase (캡처링 단계)**

   * `window` → `document` → `<html>` → `<body>` → … → *타깃 요소*
   * “위에서 아래로 내려가며” 이벤트가 통과하는 단계

2. **Target Phase (타깃 단계)**

   * 실제 이벤트가 발생한 타깃 요소에서 실행되는 단계

3. **Bubbling Phase (버블링 단계)**

   * *타깃 요소* → 부모 → 조상 → `<body>` → `<html>` → `document` …
   * “아래에서 위로 올라가는” 단계

자바스크립트에서:

* `elem.addEventListener('click', handler, true)` 👉 **캡처링** 핸들러
* `elem.addEventListener('click', handler, false)` 👉 **버블링** 핸들러(기본값)

이 구조를 리액트가 “그대로 쓰면서도” 약간 포장해서 제공하는 것이 **합성 이벤트(SyntheticEvent)** 시스템입니다.

---

## 2. 리액트 이벤트 시스템의 큰 그림 🧩

리액트는 DOM에다가 **모든 이벤트 리스너를 각 요소마다 직접 달지 않습니다.**

대신:

* **루트 컨테이너**(예: `#root`)에 소수의 이벤트 리스너를 등록해두고
* 이벤트가 발생하면 **이벤트를 한 번만 받아서**
* 내부적으로 **리액트 트리(VDOM/Fiber 트리)를 따라가며**
  어떤 컴포넌트에 어떤 핸들러가 있는지 찾아서 호출합니다.

이때 리액트는:

* DOM의 **Capturing / Bubbling** 구조를 그대로 이용하지만
* 우리가 JSX에서 쓰는 `onClick`, `onClickCapture` 에 대해
  **자기만의 규칙으로** 순서를 엄격하게 보장해 줍니다.

즉, 개발자가 보는 세계는:

```jsx
<div onClickCapture={...} onClick={...}>
  <button onClickCapture={...} onClick={...} />
</div>
```

* `onClickCapture`  👉 캡처링 단계에 실행
* `onClick`         👉 버블링 단계에 실행

으로 보이지만, 실제로는 리액트가 **루트에서 한 번** 이벤트를 받고, 내부적으로 **“캡처 핸들러 → 타깃 → 버블 핸들러”** 순서로 SyntheticEvent를 흘려보내는 구조입니다.

---

## 3. JSX에서의 Event Capturing: `onClickCapture` 🧷

리액트에서 캡처링 이벤트를 사용하려면 단순합니다.

```jsx
<div onClickCapture={handleCapture} onClick={handleBubble}>
  <button onClickCapture={handleButtonCapture} onClick={handleButtonClick}>
    클릭
  </button>
</div>
```

여기서 실제 실행 순서를 차근차근 써보면:

1. **Capturing Phase**

   * 가장 바깥(상위) 컴포넌트의 `onClickCapture`부터
   * 타깃 요소의 `onClickCapture`까지 **위 → 아래 순서**로 실행

2. **Target Phase**

   * 타깃 요소에서 “타깃 단계”가 논리적으로 발생 (리액트는 크게 분리 안함)

3. **Bubbling Phase**

   * 타깃 요소의 `onClick`부터
   * 상위 요소의 `onClick`까지 **아래 → 위 순서**로 실행

위 예시에서 `<button>`을 클릭했다고 하면, 호출 순서는:

1. `div.onClickCapture`
2. `button.onClickCapture`
3. `button.onClick`
4. `div.onClick`

입니다.
즉 **캡처 핸들러는 항상 버블 핸들러보다 먼저** 호출된다는 점이 중요합니다. 🚨

---

## 4. 간단한 데모 코드로 흐름 눈으로 보기 👀

아주 단순한 예제를 만들어 보겠습니다.

```jsx
function log(msg) {
  console.log(msg);
}

export default function EventCaptureDemo() {
  return (
    <div
      onClickCapture={() => log('div capture')}
      onClick={() => log('div bubble')}
      style={{ padding: 40, border: '2px solid blue' }}
    >
      <button
        onClickCapture={() => log('button capture')}
        onClick={() => log('button bubble')}
      >
        Click me
      </button>
    </div>
  );
}
```

브라우저 콘솔에 나오는 순서:

1. `div capture`
2. `button capture`
3. `button bubble`
4. `div bubble`

이 순서를 머릿속에 딱 박아두면, 이후에 **이벤트 제어**를 할 때 훨씬 직관적으로 느껴집니다. 😊

---

## 5. 캡처링 단계에서 흐름 끊기: `stopPropagation` 🛑

이제 **이벤트 흐름을 중간에서 끊는 상황**을 보겠습니다.

### 5.1. 캡처 단계에서 끊기

```jsx
function log(msg) {
  console.log(msg);
}

export default function EventCaptureStopDemo() {
  return (
    <div
      onClickCapture={(e) => {
        log('div capture');
        e.stopPropagation();
      }}
      onClick={() => log('div bubble')}
      style={{ padding: 40, border: '2px solid blue' }}
    >
      <button
        onClickCapture={() => log('button capture')}
        onClick={() => log('button bubble')}
      >
        Click me
      </button>
    </div>
  );
}
```

여기서 `<button>`을 클릭하면 콘솔 출력은?

* `div capture` **만** 찍히고 끝납니다.

이유:

* `div`의 **캡처 단계**에서 `stopPropagation()`을 호출하면

  * 그 이후의 **캡처링 핸들러**도 실행되지 않고
  * 타깃/버블링 단계도 **모두 중단**됩니다.
* 따라서 `button capture`, `button bubble`, `div bubble` 모두 실행 X

### 5.2. 타깃/버블 단계에서 끊기

```jsx
function log(msg) {
  console.log(msg);
}

export default function EventBubbleStopDemo() {
  return (
    <div
      onClickCapture={() => log('div capture')}
      onClick={() => log('div bubble')}
      style={{ padding: 40, border: '2px solid blue' }}
    >
      <button
        onClickCapture={() => log('button capture')}
        onClick={(e) => {
          log('button bubble');
          e.stopPropagation();
        }}
      >
        Click me
      </button>
    </div>
  );
}
```

이 경우 출력 순서:

1. `div capture`
2. `button capture`
3. `button bubble`

그리고 `div bubble`은 실행되지 않습니다.

캡처 단계는 이미 끝났고, 타깃(`button`)의 버블 핸들러에서 `stopPropagation()`을 했기 때문에 **위로 올라가는 버블링만** 중단된 것입니다.

---

## 6. 브라우저 DOM vs React: 캡처링에서의 차이점 🔍

브라우저 DOM에서:

```js
parent.addEventListener('click', handler, true);   // capture
parent.addEventListener('click', handler, false);  // bubble
```

* **세 번째 인자(Boolean)** 로 캡처/버블을 구분합니다.

리액트에서:

```jsx
<div onClickCapture={handleCapture} onClick={handleBubble} />
```

* **이벤트 이름에 `Capture` suffix** 가 붙으면 캡처 단계
* `onClick` 은 버블 단계

중요한 포인트:

1. 리액트는 **합성 이벤트**로 감싸기 때문에, `e`는 `MouseEvent`가 아니라 `SyntheticEvent` 입니다. (단, `e.nativeEvent`로 원본 DOM 이벤트에 접근 가능)
2. 리액트는 하나의 루트 리스너에서 이벤트를 받아들인 후

   * **캡처 핸들러 목록을 위 → 아래 순으로 실행**
   * **버블 핸들러 목록을 아래 → 위 순으로 실행**
     하는 **자체 로직**을 가집니다.

그래서 DOM에서 수작업으로 addEventListener를 섞어 쓰는 것보다
훨씬 **예측 가능한 순서**를 보장하려고 합니다.

---

## 7. React 17+에서의 이벤트 위임 위치 변화 🏗️

리액트 16까지는 대부분의 이벤트 리스너를 **`document`에 위임(delegate)** 했습니다.
17부터는 이벤트를 **루트 컨테이너**에 위임하는 방식으로 바뀌었습니다.

예:

```jsx
import ReactDOM from 'react-dom/client';

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(<App />);
```

* 리액트는 `#root`에 이벤트 리스너를 걸고
* 그 안에서 일어나는 클릭 등 이벤트를 처리합니다.

이 변경의 의미:

* 페이지에 여러 개의 리액트 앱이 공존할 때, 각 앱이 자신의 컨테이너 안에서만 이벤트를 관리할 수 있어 **호환성 증가**
* 다른 JS 프레임워크와 동시에 쓸 때 이벤트 충돌 줄어듦

하지만 **개발자가 사용하는 `onClickCapture`, `onClick`의 의미와 순서**는 변하지 않았습니다.
즉, 여러분 입장에서는 “동작은 똑같이 보인다”고 생각하시면 됩니다. 😄

---

## 8. 실무에서 Capturing을 쓰는 대표적인 패턴들 💼

### 8.1. 최상위에서 “이벤트 로깅” 또는 “권한 체크” 하기

상위 레이아웃 컴포넌트에서 모든 클릭을 관찰하고 싶을 때:

```jsx
function AppLayout({ children }) {
  const handleAnyClickCapture = (e) => {
    const target = e.target;
    console.log('Clicked element:', target);
    // 예: 분석 이벤트 전송, 권한 체크 등
  };

  return (
    <div onClickCapture={handleAnyClickCapture}>
      {children}
    </div>
  );
}
```

* 캡처 단계에서 처리하면, **버블 단계에서 `stopPropagation()`이 일어나더라도**
  로깅은 이미 끝난 상태라 더 안전합니다.

### 8.2. 특정 영역으로 이벤트가 들어오는 순간 감지하기

예를 들어 모달 내부 클릭과 모달 외부 클릭을 다른 로직으로 처리할 때,
모달 컨테이너에서 캡처링을 활용할 수 있습니다.

```jsx
function Modal({ onClose }) {
  const handleBackdropClick = () => {
    onClose();
  };

  const handleContentClickCapture = (e) => {
    // 모달 내용 내부에서 클릭이 발생한 경우,
    // 버블링으로 백드롭에 도달하기 전에 차단
    e.stopPropagation();
  };

  return (
    <div
      className="backdrop"
      onClick={handleBackdropClick} // 버블 단계
    >
      <div
        className="modal-content"
        onClickCapture={handleContentClickCapture}
      >
        {/* 이 안에서 어떤 클릭이 일어나도 onClose 호출 X */}
        ...
      </div>
    </div>
  );
}
```

포인트:

* 모달 내용 안에서의 클릭은 `modal-content`의 `onClickCapture`에서 `stopPropagation`
  → 버블링이 백드롭까지 도달하지 않음 → `onClose` 호출 안 됨
* 바깥 백드롭을 직접 클릭하면 바로 `backdrop.onClick`이 실행 → 모달 닫힘

이 패턴은 **“바깥 클릭만 닫기”** 구현에서 자주 쓰입니다.

---

## 9. SyntheticEvent, event.persist, 그리고 캡처와의 관계 🧪

리액트의 `SyntheticEvent`는 **풀링(pooling)** 을 사용해
이벤트 객체를 재사용합니다(React 17까지는 강하게, 이후는 완화).

예전에는 이런 패턴이 자주 등장했죠:

```jsx
function handleClick(e) {
  e.persist(); // SyntheticEvent 풀에서 제거 → 나중에 비동기에서도 안전하게 사용
  setTimeout(() => {
    console.log(e.target); // persist 안 하면 여기서는 이미 null일 수 있음
  }, 1000);
}
```

이 부분은 **캡처/버블과 직접적인 연관은 없지만**,
이벤트가 **하나의 SyntheticEvent 인스턴스로 캡처 → 버블 전체를 순회**한다는 점이
리액트 이벤트 시스템의 중요한 특징입니다.

* `onClickCapture` 에서 받은 `e`와
* `onClick`에서 받는 `e`는 동일한 SyntheticEvent 인스턴스입니다.
* 따라서 캡처 단계에서 `e.stopPropagation()`을 호출하면
  버블 단계에서도 이미 `isPropagationStopped()`가 true인 상태로 인식됩니다.

---

## 10. 자주 하는 오해 & 주의사항 ⚠️

1. **“deps에 따라 useEffect가 호출 여부가 결정되지?”처럼,
   이벤트도 props/state처럼 “변경 여부”가 기준일 것이라고 생각하는 오해**

   → 이벤트는 **발생할 때마다** 캡처/버블 흐름을 타고 내려갑니다.
   state와 달리 “변경 여부”가 기준이 아니고, **사용자의 행동**이 기준입니다.

2. `onClickCapture`와 `onClick`이 혼재된 트리에서
   `stopPropagation`을 “어디서” 호출하느냐에 따라
   흐름이 완전히 달라진다는 점을 항상 명확히 해야 합니다.

3. DOM의 `addEventListener('click', handler, true)`와
   React의 `onClickCapture` 를 **섞어 쓰면 호출 순서를 예측하기 어려워질 수** 있습니다.
   가능하면 **하나의 세계관(React SyntheticEvent)** 에서만 이벤트를 제어하는 것이 좋습니다.

4. React 17+에서 이벤트 위임 위치가 컨테이너로 바뀌었지만,
   기존 코드의 로직이나 순서가 깨지지 않도록 **compat** 되게 설계되었습니다.
   내부 구조만 바뀌었을 뿐, `onClickCapture` / `onClick`의 의미는 동일합니다.

---

## 11. 정리 🧾

* 브라우저 이벤트는 **캡처링 → 타깃 → 버블링** 3단계
* 리액트는 이를 기반으로 **합성 이벤트 시스템**을 구현하고,

  * `onClickCapture` 👉 **캡처 단계**
  * `onClick` 👉 **버블 단계**
    로 나누어 제공합니다.
* 실제 실행 순서:

  * 상위 컴포넌트의 `onClickCapture` → 하위 컴포넌트의 `onClickCapture`
    → 타깃 → 하위의 `onClick` → 상위의 `onClick`
* `stopPropagation()`은 호출 위치에 따라

  * 이후 **캡처 + 버블 전체**를 막거나
  * **버블만** 막을 수 있습니다.
* React 17+에서는 이벤트 위임이 `document` → 루트 컨테이너로 옮겨졌지만,
  우리가 사용하는 `onClickCapture`/`onClick`의 의미와 순서는 그대로입니다.


