# 🎯 **Hook 메모리 슬롯이란?**

👉 **React가 함수형 컴포넌트의 각 Hook(useState, useEffect 등)을 저장하기 위해
Fiber 노드 안에 만들어 놓은 “연결 리스트 형태의 저장 공간(slot)”입니다.**

즉, 컴포넌트 안에서 Hooks를 **순서대로 호출한 그대로** React가 기록해두는 저장소입니다.

---

## 🧩 왜 이런 저장소가 필요한가?

함수형 컴포넌트는 **매 렌더링마다 함수가 다시 실행**됩니다.

```jsx
function Counter() {
  const [count, setCount] = useState(0);  // ← 이 값은 함수가 재실행되어도 유지돼야 함
}
```

문제:

* 일반 함수라면 변수가 유지되지 않음
* Hook은 함수 내부에 있으니 함수 실행이 끝나면 사라져야 함
* 그런데 React는 이 상태를 **계속 유지해야** 함

💡 그래서 React는 “컴포넌트 외부”에 상태를 저장하는 영역을 만듭니다.
그게 바로 **Hook 메모리 슬롯**입니다.

✅ Hook 메모리 슬롯은 “컴포넌트 인스턴스(Fiber)” 당 하나씩 만들어집니다.

즉,

👉 컴포넌트 하나가 렌더링될 때, 그 컴포넌트 전용의 Hook 저장 슬롯(Fiber.memoizedState)이 생성됩니다.
👉 이 슬롯은 그 컴포넌트가 살아 있는 동안 유지되며, 리렌더될 때마다 재사용됩니다.

---

## 🧠 Hook 메모리 슬롯의 실제 구조

React는 각 컴포넌트를 Fiber node로 관리합니다.

```
FiberNode {
  memoizedState: Hook | null
}
```

이 memoizedState 아래에 Hook들이 **연결 리스트(Linked List)** 로 저장됩니다.
> 🔥 memoizedState = 해당 컴포넌트의 Hook 메모리 슬롯(List)의 시작점(head)
> React는 함수형 컴포넌트를 렌더링할 때, Hook 데이터를
> Fiber.memoizedState에 연결 리스트 형태로 저장합니다.

예를 들어:

```jsx
function App() {
  const [a, setA] = useState(0);        // Hook Slot 1
  const [b, setB] = useState(0);        // Hook Slot 2
  useEffect(() => {...}, []);           // Hook Slot 3
}
```

React 내부 구조는 다음과 같은 형태:

```
Fiber.memoizedState → Hook1 → Hook2 → Hook3 → null
```

각 Hook 노드는 이런 형태입니다:

```
Hook {
  memoizedState: any,               // useState 값, useEffect cleanup 등 저장
  queue: UpdateQueue,               // setState 때문에 쌓인 업데이트 기록
  next: Hook | null                 // 다음 Hook
}
```

즉, 컴포넌트 하나마다…

🔥 “Hook들이 순서대로 저장된 Linked List”를 React가 가지고 있습니다.
🔥 이 저장소 하나하나를 **Hook 메모리 슬롯**이라고 합니다.

---

# 🎣 렌더링 시 React는 이렇게 동작합니다:

1. 컴포넌트를 렌더링하며 Hooks를 순서대로 호출함
2. 각 호출 시 React는 다음 Hook 슬롯으로 이동
3. 이전 렌더에서 저장해둔 값(`memoizedState`)을 가져옴
4. 업데이트 큐(queue)에 있는 pending update를 적용해 새 값 계산
5. 다음 Hook 슬롯으로 이동

이때 “순서”가 매우 중요합니다.

---

# 🚨 왜 Hooks는 조건문 안에서 호출하면 안 되나?

이유는 하나입니다.

### 👉 Hook 메모리 슬롯은 “순서” 기반으로 매칭되기 때문입니다.

예시(잘못된 코드):

```jsx
if (login) {
  const [a, setA] = useState(0); // ← Hook Slot 1 이었다가
}
const [b, setB] = useState(0);   // ← Hook Slot 2
```

다음 렌더링에서 `login=false`라면:

```
Slot 1 없음 → b가 Slot1로 매칭됨 → 완전 엉망 → React 오류 발생
```

React는 “Hook을 실행한 순서”만 기억하며,
조건문 안에 Hook이 들어가면 이 순서가 깨져서 매칭 불가.

---

# 🧨 Hook 메모리 슬롯을 아주 간단히 비유하면

### 📚 “React가 Hook을 배열(리스트)에 저장해두고,

다음 렌더링 때도 순서대로 그 배열을 다시 사용하는 것”

그래서 다음이 성립합니다:

* useState를 3번 쓰면 Hook 슬롯도 3개
* useEffect를 쓰면 그 다음 슬롯에 effect 정보 저장
* useRef도 슬롯 하나 사용

즉:

👉 “컴포넌트를 렌더링할 때 React가 Hook 호출 순서를 따라가며
정해진 슬롯에 상태/효과 정보를 저장하고 재사용하는 메커니즘”

---

# 🏁 최종 요약

### ✔ Hook 메모리 슬롯이란?

**React Fiber가 함수형 컴포넌트의 상태·effect 등을 저장하는
hook 전용 저장 공간이며, Hook 호출 순서대로 연결 리스트 형태로 유지되는 구조.**

### ✔ 왜 중요한가?

* Hook을 어떤 순서로 호출했는지 기억
* 다음 렌더링에도 같은 Hook과 매칭
* Hook의 규칙(조건문 금지)이 이 구조 때문에 강제됨

### ✔ 어떤 Hook이든 모두 이 슬롯에 저장된다

* useState → state + updater queue
* useEffect → effect + cleanup 저장
* useMemo → 계산된 값 저장
* useCallback → 함수 reference 저장
* useRef → ref object 저장


