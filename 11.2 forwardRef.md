`forwardRef`는 **부모가 가진 ref를 자식 컴포넌트 “안쪽”까지 그대로 전달(forwarding)해 주는 특수 기술**입니다.
함수 컴포넌트 + `ref` 조합을 제대로 이해하려면 꼭 짚고 넘어가야 하는 개념이에요. 🚀

---

## 1. 왜 `forwardRef`가 필요한가? (문제 상황부터) 🤔

기본 규칙부터 짚어보겠습니다.

```jsx
function MyInput() {
  return <input />;
}

function App() {
  const inputRef = useRef(null);

  return (
    <div>
      {/* ❌ 이렇게 하면 에러 or 경고 */}
      <MyInput ref={inputRef} />
    </div>
  );
}
```

위 코드는 왜 문제가 될까요?

* `ref`는 `<div ref=...>` 처럼 **DOM 요소**나
  `<SomeClassComponent ref=...>` 처럼 **클래스 컴포넌트**에는 바로 사용 가능하지만,
* **일반 함수 컴포넌트**에는 그대로 붙지 않습니다.
  (함수 컴포넌트는 인스턴스가 없기 때문)

React 입장에서 JSX 엘리먼트는 대략 이런 구조로 관리됩니다:

```ts
{
  type,   // 컴포넌트 타입 (함수, 클래스, 'div', 'span' 등)
  key,
  ref,    // ref는 props와는 별도 필드!
  props,
}
```

* `ref`는 props 안에 들어가지 않고, 별도 필드로 다뤄짐
* 함수 컴포넌트는 **인스턴스(instance)**가 없기 때문에, `ref`를 달아 줄 대상이 없음

그래서 React는:

> “함수 컴포넌트에 ref를 직접 달긴 애매한데…
> 필요하면 내가 ref를 자식 DOM까지 넘겨 줄게. 대신 너가 `forwardRef`로 알려줘.”

라는 방식으로 설계를 해둔 거고, 그 때 쓰는 API가 바로 `React.forwardRef`입니다. 🪄

---

## 2. `forwardRef` 기본 문법 🧩

### 2-1. 기본 형태

```jsx
const MyInput = React.forwardRef((props, ref) => {
  return <input {...props} ref={ref} />;
});
```

* `React.forwardRef`에 **렌더 함수**를 인자로 넘깁니다.
* 이 렌더 함수의 **두 번째 인자**로 `ref`가 들어옵니다.
* 이제 부모 컴포넌트가 `<MyInput ref={...} />` 라고 쓰면

  * 그 `ref`가 이 렌더 함수의 두 번째 파라미터로 전달되고
  * 우리가 원하는 **어떤 실제 대상**(보통 DOM)에 붙여 줄 수 있습니다.

### 2-2. 부모에서 사용하는 모습

```jsx
function App() {
  const inputRef = useRef(null);

  const focusInput = () => {
    inputRef.current?.focus();
  };

  return (
    <div>
      <MyInput ref={inputRef} placeholder="forwardRef 예제" />
      <button onClick={focusInput}>포커스 주기</button>
    </div>
  );
}
```

* 부모는 `<MyInput ref={inputRef} />` 처럼 사용
* 자식 `MyInput`은 내부에서 `<input ref={ref} />`로 실제 DOM에 ref를 달아 줌
* 이제 부모는 `inputRef.current`로 **진짜 `<input>` DOM**에 접근 가능 ✅

---

## 3. `props`와 `ref`의 차이: 왜 ref는 두 번째 인자로 오나? 🧠

많이들 헷갈리는 포인트:

> “왜 ref는 `props.ref`로 안 오고, 두 번째 인자로 따로 오지?”

React 엘리먼트 구조에서 `ref`는 `props`와 분리된 필드라고 말했죠.
이 구조 때문에 `forwardRef` 렌더 함수는 이렇게 정의됩니다:

```ts
type ForwardRefRenderFunction<TInstance, TProps> = (
  props: TProps,
  ref: React.Ref<TInstance> | null
) => ReactNode;
```

즉,

* `props` : 일반 JSX 속성 (`title`, `placeholder`, `onClick`, …)
* `ref` : 별도의 필드로 관리되는 리액트 특수 속성

**중요 포인트**

* JSX에서 `ref`는 **컴포넌트 외부와 내부를 연결하는 “비공개 채널”** 느낌
* `forwardRef`로 “이 ref를 어디에 붙일지”를 명시적으로 알려줘야 함
* 그래서 “props 안에 심어 보내는 것”이 아니라 “두 번째 인자로 따로” 받음

---

## 4. 기본 패턴: DOM에 ref를 전달하는 래퍼 컴포넌트 만들기 🧱

UI 라이브러리, 디자인 시스템에 자주 등장하는 패턴입니다.

### 예제: 스타일 입힌 Input 컴포넌트

```jsx
import React, { forwardRef } from 'react';

const TextInput = forwardRef(function TextInput(props, ref) {
  const { label, ...rest } = props;

  return (
    <label style={{ display: 'block', marginBottom: '8px' }}>
      <span style={{ display: 'block', marginBottom: '4px' }}>{label}</span>
      <input
        ref={ref}        // 🔥 부모가 준 ref를 DOM에 부착
        style={{
          padding: '8px 12px',
          borderRadius: '4px',
          border: '1px solid #ccc',
        }}
        {...rest}
      />
    </label>
  );
});

export default TextInput;
```

사용:

```jsx
function App() {
  const inputRef = useRef(null);

  const handleFocus = () => {
    inputRef.current?.focus();
  };

  return (
    <div style={{ padding: 20 }}>
      <TextInput ref={inputRef} label="이름" placeholder="홍길동" />
      <button onClick={handleFocus}>입력창 포커스</button>
    </div>
  );
}
```

이 패턴의 의미:

* 라이브러리/공용 컴포넌트 입장에서는 **겉모습 + 공통 로직**을 캡슐화하고
* 부모는 여전히 `ref`로 **안쪽 DOM 제어**가 가능

---

## 5. `forwardRef + useImperativeHandle`로 “컨트롤 가능한 컴포넌트” 만들기 🎮

`forwardRef`를 쓰면 단순히 DOM만 노출할 필요는 없습니다.
`useImperativeHandle`과 조합하면 **“부모가 사용할 수 있는 메서드 집합”**을 정의할 수 있습니다.

### 5-1. 예제: 커스텀 Input with focus + clear 메서드

```jsx
import React, { forwardRef, useImperativeHandle, useRef } from 'react';

const FancyInput = forwardRef(function FancyInput(props, ref) {
  const inputRef = useRef(null);

  // 부모에게 노출할 "공개 메서드" 정의
  useImperativeHandle(ref, () => ({
    focus() {
      inputRef.current?.focus();
    },
    clear() {
      if (inputRef.current) {
        inputRef.current.value = '';
      }
    },
    getValue() {
      return inputRef.current?.value;
    },
  }));

  return (
    <input
      {...props}
      ref={inputRef}
      style={{ padding: '8px 12px', border: '1px solid #aaa' }}
    />
  );
});

export default FancyInput;
```

부모 컴포넌트:

```jsx
function App() {
  const fancyRef = useRef(null);

  const handleFocus = () => {
    fancyRef.current?.focus();   // 메서드 호출
  };

  const handleClear = () => {
    fancyRef.current?.clear();
  };

  const handleLog = () => {
    console.log('현재 값:', fancyRef.current?.getValue());
  };

  return (
    <div style={{ padding: 20 }}>
      <FancyInput ref={fancyRef} placeholder="forwardRef + useImperativeHandle" />
      <div style={{ marginTop: 10 }}>
        <button onClick={handleFocus}>포커스</button>
        <button onClick={handleClear}>지우기</button>
        <button onClick={handleLog}>값 콘솔 출력</button>
      </div>
    </div>
  );
}
```

**포인트 요약** ✍️

* `forwardRef`로 부모 ref를 컴포넌트 안으로 가져온 다음
* `useImperativeHandle(ref, () => ({ ...메서드 }))`로

  * `ref.current`에 DOM이 아닌 **메서드 집합**을 할당
* 외부에서는 “클래스 인스턴스처럼” 메서드 호출이 가능
  → **Controlled Component를 한 단계 더 감싼 “또 다른 컨트롤 레벨”**을 만들 수 있음

---

## 6. HOC(고차 컴포넌트)와 `forwardRef`: ref가 사라지는 문제 해결 ⚠️

고차 컴포넌트(HOC)를 만들 때 자주 발생하는 문제가 있습니다.

```jsx
function withLogger(WrappedComponent) {
  return function Wrapper(props) {
    console.log('렌더링:', WrappedComponent.name);
    return <WrappedComponent {...props} />;
  };
}

const FancyButton = React.forwardRef(/* ... */);

// ❌ 이렇게 하면 ref가 Wrapper에 걸리고, 원래 컴포넌트로 안 내려감
const LoggedButton = withLogger(FancyButton);
```

부모에서:

```jsx
<LoggedButton ref={btnRef} />
```

하면

* `ref`는 `Wrapper` 함수 컴포넌트에 달림
* 실제 `FancyButton`까지 내려가지 않음
* 결과적으로 **ref가 끊겨버리는 문제** 발생

이걸 해결하기 위해 HOC 내부에서 다시 `forwardRef`를 써야 합니다.

```jsx
function withLogger(WrappedComponent) {
  const WithLogger = (props, ref) => {
    console.log('렌더링:', WrappedComponent.displayName || WrappedComponent.name);
    return <WrappedComponent {...props} ref={ref} />;
  };

  return React.forwardRef(WithLogger);
}
```

* 이렇게 하면

  * 부모의 `ref` → HOC (`forwardRef`) → 실제 WrappedComponent로 전달
* 라이브러리에서 ref가 잘 동작하는 이유가 대부분 이런 패턴 덕분입니다.

---

## 7. 리액트 내부적으로 `forwardRef`는 어떻게 동작하나? (개념적 관점) 🧬

실제 구현은 훨씬 복잡하지만, 개념적으로는 이런 느낌이라고 볼 수 있습니다:

```js
function forwardRef(render) {
  return {
    $$typeof: REACT_FORWARD_REF_TYPE,
    render,  // (props, ref) => ReactNode
  };
}
```

React가 렌더링할 때:

1. 엘리먼트의 `type`을 검사
2. `type.$$typeof`가 `REACT_FORWARD_REF_TYPE`라면
3. `render` 함수를 호출하면서 `(props, ref)`를 넘김
4. 여기서 ref는 부모가 `<Component ref={...} />`로 준 ref
5. `render` 함수 안에서 ref를 DOM이나 자식 컴포넌트에 붙이는 건 개발자 몫

즉, `forwardRef`는

> “이 컴포넌트는 ref를 두 번째 인자로 받을 준비가 되어 있다”

는 것을 React에게 알려주는 **마커(marker)** 역할을 한다고 보면 됩니다.

---

## 8. TypeScript에서의 `forwardRef` 사용 🧪

TS까지 쓰면 시그니처가 중요해집니다.

```tsx
import React, { forwardRef } from 'react';

type TextInputProps = React.InputHTMLAttributes<HTMLInputElement> & {
  label: string;
};

const TextInput = forwardRef<HTMLInputElement, TextInputProps>(
  ({ label, ...rest }, ref) => {
    return (
      <label>
        <span>{label}</span>
        <input ref={ref} {...rest} />
      </label>
    );
  }
);

// 이름을 지정하면 DevTools에서 보기 좋음
TextInput.displayName = 'TextInput';

export default TextInput;
```

* `forwardRef<TInstance, TProps>(…)` 제네릭을 활용해서

  * `TInstance` : `ref.current`의 타입 (`HTMLInputElement`)
  * `TProps` : 컴포넌트의 props 타입

---

## 9. 자주 하는 실수 & 주의할 점 ⚠️

### 9-1. `ref`를 props로 받아버리는 실수

```jsx
function MyComponent(props) {
  // ❌ 이렇게 하면, 부모가 준 ref는 여기 안 옴
  const { ref, ...rest } = props;
  ...
}
```

* `ref`는 JSX에서 **props로 전달되지 않는다** (별도 필드)
* forwardRef를 쓰지 않으면 함수 컴포넌트는 ref를 받을 수 없음

### 9-2. `forwardRef` 안 쓰고 함수 컴포넌트에 ref를 직접 주기

```jsx
function Child() {
  return <div>Child</div>;
}

function App() {
  const ref = useRef(null);
  return <Child ref={ref} />; // ❌
}
```

* 경고: "Function components cannot be given refs" 류 메시지
* 이 경우엔 반드시 `forwardRef`로 감싸야 함

### 9-3. `useImperativeHandle` 남용

* 가능하면 DOM 자체를 ref로 노출하는 정도에 그치는 게 좋고
* 정말 필요한 경우(복잡한 UI 위젯, 포커스 관리, 애니메이션 트리거 등)에만 메서드 노출
* 그렇지 않으면 컴포넌트가 “클래스 인스턴스”처럼 되어버려서 **선언적(Declarative)**인 스타일이 무너질 수 있음

---

## 10. 정리: 언제 `forwardRef`를 써야 할까? 🎯

✅ `forwardRef`가 필요한 대표 상황들:

1. **스타일/레이아웃을 감싼 래퍼 컴포넌트**인데
   안쪽 실제 DOM에 포커스/스크롤 제어가 필요할 때
2. 외부 라이브러리(예: `react-hook-form`, `React Transition Group`, 포커스 트랩 등)가
   **ref를 필요로 하는데**, 내가 만든 커스텀 컴포넌트에 그 ref를 전달해야 할 때
3. HOC, 디자인 시스템, UI 컴포넌트 라이브러리처럼

   * **“겉만 감싸는 컴포넌트”**를 만들면서도
   * 원래의 ref 기능을 그대로 노출해 줘야 할 때
4. `forwardRef + useImperativeHandle`로

   * 모달, 드롭다운, 캐러셀 같은 **상태 많은 위젯**에
   * “열기/닫기/스크롤/리셋” 같은 메서드를 제공하고 싶을 때

