## 1. 왜 “React DOM 이벤트 시스템”을 따로 알아야 하나요? 🤔

브라우저에서 이벤트를 다루는 기본 방식은 다음과 같습니다.

```js
const button = document.querySelector('button');

button.addEventListener('click', (event) => {
  console.log('clicked!', event);
});
```

React에서도 겉으로는 비슷해 보입니다.

```jsx
<button onClick={(event) => console.log('clicked!', event)}>클릭</button>
```

하지만 내부적으로는 **완전히 다른 구조**를 가집니다.

* 브라우저: **각 DOM 노드마다** `addEventListener`를 등록
* React: 실제로는 **루트 컨테이너 한 곳에만** 이벤트 리스너를 등록하고,
  내부의 React 요소들에 대해서는 **“이벤트 위임(event delegation)”**으로 처리
* 핸들러에 넘어오는 `event`는 브라우저의 원시 이벤트가 아니라
  React가 감싸서 제공하는 **`SyntheticEvent`(합성 이벤트)** 객체

따라서 React DOM 이벤트를 이해하려면:

1. JSX에서 이벤트 핸들러를 어떻게 등록하는지
2. `SyntheticEvent`가 무엇인지
3. React의 이벤트 버블링/캡처가 어떻게 동작하는지
4. Native DOM과 무엇이 다른지
   를 함께 보셔야 합니다.

---

## 2. JSX에서 이벤트 핸들러를 등록하는 기본 문법 🔧

### 2-1. 이벤트 이름: 소문자 `onclick`이 아니라 `onClick`

DOM:

```html
<button onclick="handleClick(event)">클릭</button>
```

React / JSX:

```jsx
<button onClick={handleClick}>클릭</button>
```

차이점:

* **이벤트 이름은 카멜 케이스(camelCase)**

  * `onclick` ❌ → `onClick` ✅
  * `onchange` ❌ → `onChange` ✅
* **문자열이 아니라 함수 레퍼런스**를 넘김

  * `onClick="handleClick()"` ❌
  * `onClick={handleClick}` ✅

---

### 2-2. JSX에서 함수 전달 vs 즉시 실행 주의 ⚠️

```jsx
// ❌ 이렇게 쓰면 렌더링 시점에 바로 실행됨
<button onClick={handleClick()}>클릭</button>

// ✅ 함수 그 자체를 넘겨야 함
<button onClick={handleClick}>클릭</button>
```

파라미터를 넘기고 싶다면?

```jsx
function handleClick(id, event) {
  console.log(id, event.type);
}

// 가장 흔한 패턴
<button onClick={(event) => handleClick(42, event)}>클릭</button>
```

여기서 `event`는 **React SyntheticEvent**입니다 (뒤에서 자세히 설명).

---

## 3. React의 SyntheticEvent란? 🧪

React에서 이벤트 핸들러의 첫 번째 인자는 **브라우저 Native Event가 아니라,
`SyntheticEvent`라는 래퍼 객체**입니다.

```jsx
function handleClick(event) {
  console.log(event.type);          // "click"
  console.log(event.target);        // 실제 DOM 노드
  console.log(event.currentTarget); // 이벤트가 바인딩된 DOM 노드
}
```

### 3-1. SyntheticEvent의 역할

1. **브라우저 간 차이 통합**

   * 예전 IE / 최신 Chrome / Firefox 등 브라우저 간 이벤트 차이를 감싸서
     항상 동일한 API로 접근 가능하게 해줍니다.

2. **이벤트 위임 구조에 맞는 정보 제공**

   * React는 실제로는 **루트에서 이벤트를 듣지만**,
     `event.currentTarget`, `event.target` 등을 통해
     **마치 각각의 DOM에 직접 바인딩된 것처럼** 보여줍니다.

3. **이벤트 풀링(Event Pooling) (과거)**

   * React 16 이전에는 성능 최적화를 위해 SyntheticEvent 객체를 재사용(pooled)했지만,
     지금은 대부분 버전에서 **실질적으로 pooling이 비활성화**된 상태라고 보셔도 됩니다.
     (옛날 자료에서 “이벤트를 비동기에서 쓰려면 `event.persist()`를 호출해야 한다”는 내용을
     보셨다면, **요즘은 크게 신경 안 써도 되는 부분**입니다.)

---

## 4. React의 이벤트 위임(Event Delegation) 구조 🕸️

브라우저 DOM의 전통적인 방식:

```js
button1.addEventListener('click', handler);
button2.addEventListener('click', handler);
button3.addEventListener('click', handler);
```

DOM 요소가 많아질수록 **리스너 수가 증가**하고, 메모리 사용도 늘어납니다.

React는 다음처럼 작동합니다.

1. React가 `createRoot`로 앱을 마운트할 때,
   **루트 컨테이너에 한 번만** `click`, `change` 등 주요 이벤트 리스너를 등록
2. 실제 클릭이 발생하면:

   * 브라우저는 루트 컨테이너의 리스너에 이벤트를 전달
   * React 내부에서 **이벤트의 발생 위치(target)**를 추적
   * Virtual DOM 트리 상에서 **적절한 컴포넌트의 핸들러**를 찾아 호출
3. 이 과정 전체를 통해, React는 **“각 노드에 리스너를 건 것처럼”** 동작시킵니다.

장점:

* DOM 노드 수에 비해 **이벤트 리스너가 적다** → 메모리 사용 감소
* 이벤트 관리 로직이 React 내부로 모여서 **일관된 동작** 보장
* 리렌더링 시 매번 DOM 이벤트를 attach/detach하지 않아도 됨

---

## 5. 이벤트 버블링 & 캡처 in React 🌊

이제 사용자가 자주 헷갈리는 **이벤트 버블링과 캡처**를
“브라우저 DOM vs React” 두 관점에서 정리해보겠습니다.

### 5-1. 브라우저의 기본 이벤트 흐름

DOM에서 이벤트 흐름은 세 단계입니다.

1. **캡처링 단계 (Capturing Phase)**

   * window → document → html → body → … → target
   * 이벤트가 위에서 아래로 “내려가는” 단계

2. **타깃 단계 (Target Phase)**

   * 실제 타깃에서 이벤트가 발생

3. **버블링 단계 (Bubbling Phase)**

   * target → 부모 → 조상 → … → document → window
   * 이벤트가 아래에서 위로 “올라가는” 단계

```html
<div id="parent">
  <button id="child">Click me</button>
</div>
```

```js
parent.addEventListener('click', () => console.log('parent'), false); // 버블링
child.addEventListener('click', () => console.log('child'), false);
```

* 버튼 클릭 → `child` 핸들러 → `parent` 핸들러 순으로 실행

---

### 5-2. React에서 버블링: `onClick`

React는 기본적으로 **버블링 단계에서 이벤트를 처리**합니다.

```jsx
function Parent() {
  const onParentClick = () => console.log('Parent');
  const onChildClick = () => console.log('Child');

  return (
    <div onClick={onParentClick}>
      <button onClick={onChildClick}>Click</button>
    </div>
  );
}
```

버튼을 클릭하면 콘솔 출력:

```text
Child
Parent
```

React가 내부적으로는 SyntheticEvent를 이용해
DOM 버블링 결과를 **Virtual DOM 트리의 계층 관계**에 맞게
다시 매핑해주고 있다고 보시면 됩니다.

---

### 5-3. React에서 캡처링: `onClickCapture`

브라우저의 `capture: true` 옵션에 해당하는 것이
React에서는 **`onClickCapture`** 입니다.

```jsx
function Parent() {
  const onParentCapture = () => console.log('Parent Capture');
  const onParentBubble = () => console.log('Parent Bubble');
  const onChildClick = () => console.log('Child');

  return (
    <div
      onClickCapture={onParentCapture}
      onClick={onParentBubble}
    >
      <button onClick={onChildClick}>Click</button>
    </div>
  );
}
```

버튼 클릭 시 출력 순서:

```text
Parent Capture   // 캡처 단계
Child            // 타깃
Parent Bubble    // 버블링 단계
```

정리:

* **캡처 단계에서 일찍 가로채고 싶으면**: `onClickCapture`
* **일반적인 대부분의 경우**: `onClick`

---

### 5-4. 버블링 중단: `event.stopPropagation()` 🛑

DOM과 마찬가지로 React SyntheticEvent에서도
`stopPropagation()`을 호출하면 **이후 상위 핸들러가 호출되지 않도록** 막을 수 있습니다.

```jsx
function Parent() {
  const onParentClick = () => console.log('Parent');

  const onChildClick = (event) => {
    event.stopPropagation();
    console.log('Child');
  };

  return (
    <div onClick={onParentClick}>
      <button onClick={onChildClick}>Click</button>
    </div>
  );
}
```

출력:

```text
Child
```

`Parent`는 호출되지 않습니다.

---

## 6. `preventDefault()`와 `return false`의 차이 ⚖️

브라우저에서는 가끔 이런 패턴을 씁니다.

```html
<a href="https://example.com" onclick="return false;">링크</a>
```

React에서는 이렇게 하면 **동작하지 않습니다.**

```jsx
// ❌ 작동하지 않음
<a href="https://example.com" onClick={() => false}>
  링크
</a>
```

React에서는 **명시적으로 `event.preventDefault()`를 호출**해야 합니다.

```jsx
function LinkLikeButton() {
  const handleClick = (event) => {
    event.preventDefault(); // 기본 동작(페이지 이동) 막기
    console.log('링크를 클릭했지만, 이동은 막았음');
  };

  return (
    <a href="https://example.com" onClick={handleClick}>
      링크
    </a>
  );
}
```

정리:

* DOM: `return false` → (전통적으로) `preventDefault + stopPropagation` 역할
* React: `return false`는 **아무 의미 없음**,
  **항상 `event.preventDefault()`와 `event.stopPropagation()`을 직접 호출**해야 합니다.

---

## 7. Native DOM 이벤트 vs React 이벤트의 차이점 정리 🧬

| 항목               | 브라우저 DOM                                        | React DOM (SyntheticEvent)                  |
| ---------------- | ----------------------------------------------- | ------------------------------------------- |
| 이벤트 등록 방식        | 각 노드별 `addEventListener`                        | 루트 컨테이너 하나에 위임(Delegation)                  |
| 이벤트 객체 타입        | `MouseEvent`, `KeyboardEvent` 등                 | `SyntheticEvent` + `nativeEvent`로 원본 접근 가능  |
| 이름 표기            | `onclick`, `addEventListener('click')`          | `onClick`, `onChange` 등 camelCase JSX props |
| 기본 동작 취소         | `event.preventDefault()` or `return false` (전통) | **반드시 `event.preventDefault()` 사용**         |
| 버블링/캡처 제어        | `capture` 옵션, `stopPropagation()`               | `onClickCapture`, `event.stopPropagation()` |
| `onChange` 동작 시점 | 보통 focus out(blur) 기준                           | 입력할 때마다(실질적으로 DOM의 `input` 이벤트에 가까움)        |

### 7-1. React의 `onChange`는 사실상 “실시간 입력”

```jsx
<input
  value={value}
  onChange={(e) => setValue(e.target.value)}
/>
```

* 브라우저의 `<input>`의 `change` 이벤트는 보통 `blur` 시점에 발생하는데,
  React의 `onChange`는 `input` 이벤트처럼 **키 입력마다** 발생합니다.
* 즉, “이름이 `onChange`이지만, 의미는 DOM의 `oninput`에 가깝다” 라고 기억하시면 좋습니다.

---

## 8. 함수 컴포넌트에서 이벤트 핸들러 패턴 👨‍💻

### 8-1. 가장 기본적인 패턴

```jsx
function Counter() {
  const [count, setCount] = useState(0);

  function handleClick() {
    setCount((c) => c + 1);
  }

  return (
    <button onClick={handleClick}>
      클릭 횟수: {count}
    </button>
  );
}
```

### 8-2. 인자 전달이 필요한 경우

```jsx
function ItemList({ items, onItemClick }) {
  return (
    <ul>
      {items.map((item) => (
        <li key={item.id}>
          <button onClick={(e) => onItemClick(item.id, e)}>
            {item.name}
          </button>
        </li>
      ))}
    </ul>
  );
}
```

* `onClick={(e) => onItemClick(item.id, e)}`

  * 첫 번째 인자: 내가 추가로 넘겨주고 싶은 데이터 (item.id)
  * 두 번째 인자: 실제 SyntheticEvent

실무에서는 **이 패턴이 가장 많이 쓰입니다.**

---

## 9. 성능 관점에서 이벤트 핸들러 다루기 ⚙️

React의 이벤트 시스템이 위임 기반이라 해서,
JSX에서 아무 생각 없이 매번 새 함수를 만들어도
무조건 큰 문제가 되는 건 아닙니다. 하지만 규모가 커지면 고려해야 합니다.

### 9-1. 렌더링마다 새로 생성되는 핸들러

```jsx
<button onClick={() => doSomething(id)}>Click</button>
```

* 이 코드는 렌더링될 때마다 **새로운 함수 인스턴스**를 생성합니다.
* 대부분의 경우 큰 문제가 되지 않지만,

  * 같은 컴포넌트가 수백/수천 개 렌더링,
  * `memo`/`useCallback` 등과 엮인 상황에서는
    **불필요한 자식 리렌더**의 원인이 될 수 있습니다.

### 9-2. `useCallback`을 사용한 메모이제이션

```jsx
const handleClick = useCallback(
  (event) => {
    doSomething(id, event);
  },
  [id] // id가 바뀔 때만 새 함수 생성
);

<button onClick={handleClick}>Click</button>
```

* 이 패턴은 **자식 컴포넌트가 `React.memo`로 감싸져 있고**,
  핸들러를 props로 계속 내려 보내야 할 때 특히 유용합니다.

---

## 10. TypeScript에서의 이벤트 타입 지정 (선택) 🧾

TypeScript를 쓰실 경우, 이벤트 객체 타입을 명시하는 패턴:

```tsx
function handleClick(event: React.MouseEvent<HTMLButtonElement>) {
  console.log(event.currentTarget); // HTMLButtonElement
}
```

* 마우스 이벤트: `React.MouseEvent<HTMLElement>`
* 키보드 이벤트: `React.KeyboardEvent<HTMLInputElement>`
* 폼 제출 이벤트: `React.FormEvent<HTMLFormElement>`

이렇게 타입을 붙이면:

* `event.target`, `event.currentTarget`의 타입이 좁혀져서
  **DOM 프로퍼티 오타를 컴파일 타임에 잡을 수 있습니다.**

---

## 11. 정리: React DOM 이벤트 시스템을 한 문장으로 요약하면? 🧩

> **브라우저 DOM 이벤트 시스템 위에,
> React가 이벤트 위임 + SyntheticEvent 래퍼 + 일관된 API를 제공하는
> “가상화 된 이벤트 레이어”를 얹어놓은 것**입니다.

핵심 포인트를 다시 정리하면:

1. JSX에서는 **camelCase + 함수 레퍼런스**로 핸들러를 넘긴다.
2. React 핸들러의 `event`는 **SyntheticEvent**이며,
   `type`, `target`, `currentTarget`, `preventDefault`, `stopPropagation` 등
   DOM 이벤트와 비슷한 인터페이스를 가진다.
3. 실제 리스너는 **루트 컨테이너 한 곳에만 등록되고**,
   내부 요소들은 **이벤트 위임**으로 처리된다.
4. 버블링/캡처 모두 지원하며,

   * 버블링: `onClick`
   * 캡처: `onClickCapture`
5. `return false`는 의미가 없고, **항상 `event.preventDefault()`를 써야 한다.**
6. React의 `onChange`는 DOM의 `input` 이벤트처럼 **실시간**으로 호출된다.
7. 인자 전달이 필요할 땐 `onClick={(e) => handler(id, e)}` 패턴이 가장 실무 친화적이다.


