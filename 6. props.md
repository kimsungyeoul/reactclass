# 🌟 React Props: “UI 구성의 최소 단위”를 설계하는 가장 핵심 개념

React를 깊이 이해하는 개발자들은 **props를 단순히 ‘부모가 자식에게 주는 값’이 아니라**
**컴포넌트를 ‘순수 UI 함수로 만드는 핵심 메커니즘’** 으로 해석합니다.

React 팀도 여러 문서에서 반복해 말합니다.

> “컴포넌트는 `props`를 입력받아 UI를 반환하는 함수다.”

여기서 props는 단순한 옵션 값이 아니라
React 렌더링 엔진의 전체 동작 원리를 결정하는 **근본적인 abstraction**입니다.

---

## 1. props란 무엇인가? 🤔

### 1) 용어부터 정리

* `props` = **properties**의 줄임말
* “컴포넌트에 전달하는 데이터(설정값 + 콜백 함수 등)”를 의미
* **부모 → 자식** 방향으로만 전달되는 **단방향 데이터**입니다.

```jsx
function Welcome(props) {
  return <h1>안녕하세요, {props.name}님!</h1>;
}

<Welcome name="홍길동" />;
```

* `<Welcome name="홍길동" />`
  → `name="홍길동"` 이 부분이 **props 전달**
  → `Welcome` 함수에서 `props.name`으로 사용

### 2) “함수 호출” 관점에서 보기

이 JSX는:

```jsx
<Welcome name="홍길동" />
```

이렇게 이해하셔도 좋습니다:

```js
Welcome({ name: "홍길동" });
```

즉,

* JSX에서 **속성(attribute)** 들을 적는다.
* 리액트가 내부적으로 해당 컴포넌트 함수를 **호출할 때 아규먼트로 객체를 넘겨준다.**
* 그 아규먼트의 이름을 관습적으로 `props`라고 부르는 것.

---

## 2. JSX에서 props를 전달하는 두 가지 큰 문법 ✍️

리액트에서 props를 전달하는 문법은 크게 두 축입니다.

1. **JSX Attribute 문법**
2. **JSX Children 문법**

이 두 가지를 완전히 이해하시면, `Card`, `UserProfile`, `ActionButtons` 같은 컴포넌트 패턴이 싹 이해됩니다.

---

### 2-1. JSX Attribute 문법 📌

```jsx
<Card title="Profile" foo={123} isActive={true} user={{ name: "Kim" }} />
```

일반 HTML 속성과 비슷하게 보이지만, 몇 가지 규칙이 있습니다.

#### (1) 문자열 속성

```jsx
<Card title="Profile" />
```

* `"Profile"`은 문자열 그대로 전달됩니다.
* 호출 관점으로 보면:

```js
Card({ title: "Profile" });
```

#### (2) 자바스크립트 표현식 `{ ... }`

```jsx
<Card foo={123} isActive={true} user={{ name: "Kim" }} />
```

* `{}` 안에는 **아무 JS 표현식**이나 올 수 있습니다.

  * 숫자: `{123}`
  * 불린: `{true}`, `{false}`
  * 객체: `{{ name: "Kim" }}`
  * 배열: `{[1, 2, 3]}`
  * 함수: `{handleClick}`
* 결국은 이렇게 호출되는 것과 같습니다:

```js
Card({
  foo: 123,
  isActive: true,
  user: { name: "Kim" },
});
```

#### (3) boolean shorthand (불린 축약 표기)

```jsx
<Button primary />    // primary={true} 와 동일
<Button primary={true} />
```

* Attribute 이름만 쓰면 `true`가 들어간다고 보시면 됩니다.

#### (4) Spread 문법으로 여러 props 한 번에 전달

```jsx
const commonProps = {
  title: "Profile",
  foo: 123,
  isActive: true,
};

<Card {...commonProps} extra="hello" />;
```

내부적으로는:

```js
Card({
  title: "Profile",
  foo: 123,
  isActive: true,
  extra: "hello",
});
```

* `...commonProps` 덕분에 객체의 필드를 그대로 props로 풀어 전달하는 패턴입니다.

#### (5) `key`와 `ref` 같은 “특별한” props

```jsx
{items.map((item) => (
  <Item key={item.id} value={item} />
))}
```

* `key`, `ref`는 **리액트가 내부적으로 특별 취급**하는 props입니다.
* 자식 컴포넌트에서 `props.key`로 접근할 수 없습니다(별도로 관리).

---

### 2-2. JSX Children 문법 👶

이제 문제의 예시로 돌아가 보겠습니다.

```jsx
<Card title="Profile">
  <UserProfile />
  <ActionButtons />
</Card>
```

이 표현식에는 **두 종류의 props**가 동시에 존재합니다.

1. **명시적 props (explicit props)**

   * `title="Profile"`
2. **암묵적 props: `children`**

   * `<Card> ...여기 들어간 부분... </Card>`

즉, 내부적으로는 **이런 호출과 동일**합니다:

```js
Card({
  title: "Profile",
  children: [
    <UserProfile />,
    <ActionButtons />,
  ],
});
```

#### ✅ 정리

* `<Card title="Profile">...</Card>`
  → `title` : Attribute 문법으로 전달
  → `children` : 태그 사이의 내용이 **자동으로** `props.children`으로 전달

#### Card 컴포넌트 입장에서 사용하기

```jsx
function Card(props) {
  return (
    <div className="card">
      <h2>{props.title}</h2>
      <div className="card-body">
        {props.children}
      </div>
    </div>
  );
}
```

* `props.title` → `"Profile"`
* `props.children` → `[<UserProfile />, <ActionButtons />]`

구조 분해로 더 깔끔하게:

```jsx
function Card({ title, children }) {
  return (
    <div className="card">
      <h2>{title}</h2>
      <div className="card-body">{children}</div>
    </div>
  );
}
```

---

## 3. 컴포넌트에서 props를 “받는” 문법 🎁

### 3-1. 기본 형태: `function Component(props)`

```jsx
function Welcome(props) {
  return (
    <div>
      <p>안녕하세요, {props.name}님!</p>
      <p>나이: {props.age}</p>
    </div>
  );
}

<Welcome name="홍길동" age={20} />;
```

* 호출 관점: `Welcome({ name: "홍길동", age: 20 });`

### 3-2. 매개변수에서 **객체 구조 분해** 사용

```jsx
function Welcome({ name, age }) {
  return (
    <div>
      <p>안녕하세요, {name}님!</p>
      <p>나이: {age}</p>
    </div>
  );
}
```

* 이건 **함수 파라미터 문법**입니다.
* “props라는 객체에서 `name`, `age`를 꺼내 쓰겠다”는 의미.

내부적으로는:

```js
function Welcome(props) {
  const { name, age } = props;
  // ...
}
```

과 논리적으로 동일합니다.

### 3-3. 구조 분해 + 기본값 (Default Props)

```jsx
function Button({ label = "확인", type = "button" }) {
  return <button type={type}>{label}</button>;
}

// 사용
<Button />                   // label: "확인", type: "button"
<Button label="삭제" />      // label: "삭제", type: "button"
```

* 매개변수 구조 분해에서 기본값을 설정하면 별도의 `defaultProps`가 필요 없습니다.

### 3-4. 나머지 props 받기 (Rest Props)

```jsx
function Input({ label, ...inputProps }) {
  return (
    <label>
      {label}
      <input {...inputProps} />
    </label>
  );
}

// 사용
<Input label="이메일" type="email" placeholder="email@example.com" />;
```

⇒ 호출 관점:

```js
Input({
  label: "이메일",
  type: "email",
  placeholder: "email@example.com",
});
```

컴포넌트 안에서:

* `label` : 따로 꺼냄
* 나머지 `type`, `placeholder` 등은 `inputProps`에 모아서 `<input {...inputProps} />`로 전달

---

## 4. props의 성질: “읽기 전용 + 불변” 🧊

### 4-1. 왜 props는 수정하면 안 되는가?

```jsx
function BadComponent(props) {
  // ❌ 이렇게 하면 안 됩니다.
  props.count = props.count + 1;

  return <div>{props.count}</div>;
}
```

* 리액트에서 `props`는 **부모가 소유하는 데이터**입니다.
* 자식은 “읽기만” 해야 하고, 값을 바꾸고 싶다면 **부모에게 알려야** 합니다.

### 4-2. 값 변경이 필요할 때: 상태 끌어올리기 (Lifting State Up)

```jsx
function Parent() {
  const [count, setCount] = useState(0);

  return (
    <Counter
      count={count}
      onIncrement={() => setCount((c) => c + 1)}
    />
  );
}

function Counter({ count, onIncrement }) {
  return (
    <>
      <p>Count: {count}</p>
      <button onClick={onIncrement}>+1</button>
    </>
  );
}
```

* `count` : 상태 값은 부모가 관리
* `onIncrement` : 자식이 호출할 수 있는 “콜백 props”
* 자식 컴포넌트는 props를 **직접 수정하지 않고**, 콜백을 통해 부모의 상태 변경을 요청합니다.

---

## 5. 이벤트 핸들러도 결국 props이다 ⚙️

```jsx
function Button({ onClick, children }) {
  return <button onClick={onClick}>{children}</button>;
}

function App() {
  const handleClick = () => {
    console.log("클릭!");
  };

  return <Button onClick={handleClick}>클릭</Button>;
}
```

* `<Button onClick={handleClick}>`에서 `onClick`도 결국 **props의 한 종류**입니다.
* `Button` 내부에서 `<button onClick={onClick}>`로 DOM 이벤트에 연결해주는 것.

---

## 6. `children`을 이용한 컴포지션 패턴 🧩

다시 Card 예제로 돌아가 보겠습니다.

```jsx
<Card title="Profile">
  <UserProfile />
  <ActionButtons />
</Card>
```

`Card` 정의:

```jsx
function Card({ title, children }) {
  return (
    <section className="card">
      <header className="card-header">{title}</header>
      <div className="card-content">{children}</div>
    </section>
  );
}
```

* 이 패턴의 의미:

  * `Card`는 **레이아웃/틀**만 책임짐
  * 내부에 어떤 컴포넌트를 넣을지는 **부모(App)**가 결정
* 이런 방식의 구성 방법을 **컴포지션(Composition)**이라고 부릅니다.
* 클래스를 상속해서 커스터마이징하는 것보다 훨씬 React스러운 방식입니다.

---

## 7. 조금 더 고급: “함수형 children (render props)” 🧠

`children`은 꼭 JSX 엘리먼트일 필요는 없습니다. **함수**도 가능합니다.

```jsx
function DataFetcher({ url, children }) {
  const [data, setData] = useState(null);

  useEffect(() => {
    fetch(url)
      .then((res) => res.json())
      .then(setData);
  }, [url]);

  // children을 함수라고 가정하고 호출
  return children(data);
}

// 사용
<DataFetcher url="/api/user">
  {(user) =>
    user ? <div>안녕하세요, {user.name}님</div> : <div>로딩 중...</div>
  }
</DataFetcher>;
```

* 이런 패턴을 흔히 **“render props 패턴”**이라고 부릅니다.
* `children`에 함수를 넣고, 내부에서 `children(data)`처럼 호출해서
  데이터 기반으로 렌더링을 위임하는 방식입니다.

---

## 8. Prop Drilling과 그 대안 💧➡️💧➡️💧

### 8-1. Prop Drilling이란?

컴포넌트 구조가 깊어질 때:

```jsx
<App>
  <Layout>
    <Sidebar>
      <UserMenu>
        <UserAvatar user={user} />
      </UserMenu>
    </Sidebar>
  </Layout>
</App>
```

* `user` 정보를 `App`에서 가져와서 **중간 컴포넌트들이 필요도 없는데 계속 props로 전달**해야 하는 경우:

  * `<Layout user={user}>`
  * `<Sidebar user={user}>`
  * `<UserMenu user={user}>`
* 이렇게 “층층이 props를 넘기는 현상”을 **Prop Drilling**이라고 합니다.

### 8-2. 대안: Context, 상태 관리 라이브러리 등

* `useContext`를 사용하면 중간 단계들을 생략할 수 있습니다.
* 혹은 Redux/RTK, Recoil, Zustand 등 상태 관리 라이브러리로 관리.
* 다만 **기본은 항상 props**이고,

  * Context나 전역 상태는 “정말 자주, 광범위하게 공유하는 데이터”에 사용하는 것이 좋습니다.
  * 예: 로그인 사용자 정보, 테마, 다국어 설정 등

---

## 9. TypeScript / PropTypes와의 관계 📏

### 9-1. TypeScript로 props 타입 선언

```tsx
type ButtonProps = {
  label: string;
  type?: "button" | "submit";
  onClick?: () => void;
};

function Button({ label, type = "button", onClick }: ButtonProps) {
  return (
    <button type={type} onClick={onClick}>
      {label}
    </button>
  );
}
```

* `ButtonProps` 타입으로 **props의 구조를 명시적으로 정의**할 수 있습니다.
* IDE 자동완성, 컴파일 타임 타입 체크 등을 받을 수 있어 대규모 프로젝트에서 필수에 가깝습니다.

### 9-2. PropTypes (JS 프로젝트에서 런타임 타입 체크)

JS-only 프로젝트라면 `prop-types` 패키지를 사용해 런타임 검증을 할 수도 있습니다.

```jsx
import PropTypes from "prop-types";

function Button({ label, type, onClick }) {
  // ...
}

Button.propTypes = {
  label: PropTypes.string.isRequired,
  type: PropTypes.oneOf(["button", "submit"]),
  onClick: PropTypes.func,
};
```

---

## 10. 성능과 props: React.memo, useCallback, useMemo ⚡

### 10-1. React.memo

```jsx
const UserProfile = React.memo(function UserProfile({ user }) {
  console.log("UserProfile 렌더링");
  return <div>{user.name}</div>;
});
```

* `React.memo`는 **props가 변경되지 않으면 렌더링을 건너뛰도록** 하는 HOC입니다.
* 비교는 기본적으로 **얕은 비교(shallow equal)**로 이루어집니다.

### 10-2. 객체/함수 props에 주의

```jsx
<Child config={{ color: "red" }} onClick={() => {}} />
```

* 이런 식으로 새 객체/새 함수를 매 렌더마다 생성해 넘기면,
  `React.memo` 입장에서는 항상 “새 값”이라서 최적화 효과가 줄어듭니다.
* 이럴 때 `useCallback`, `useMemo` 등을 사용해 참조를 안정적으로 유지할 수 있습니다.

---

## 11. 정리: props를 이해하는 핵심 포인트 ✅

1. **props = 컴포넌트의 매개변수**

   * JSX `<Component ... />` → 내부적으로 `Component(props)` 호출
2. **JSX Attribute 문법**

   * `<Card title="Profile" foo={123} />`
   * 문자열, 숫자, 불린, 객체, 함수 등 JS 표현식을 `{}`로 전달
3. **JSX Children 문법**

   * `<Card> ...children... </Card>` → `props.children`으로 자동 전달
   * `<Card title="Profile"><UserProfile /><ActionButtons /></Card>`
4. **불변 + 읽기 전용**

   * 자식은 props를 **읽기만** 하고, 변경은 부모 상태를 통해
5. **이벤트 핸들러, 콜백도 props**

   * `onClick`, `onChange` 등도 단지 함수형 props
6. **컴포지션 패턴의 핵심**

   * `children`을 활용해서 레이아웃 컴포넌트, 카드, 모달 등 구성
7. **Prop Drilling과 Context**

   * 너무 깊이 전달되면 Context/전역 상태를 고려
8. **타입 시스템과 함께 사용**

   * TS 또는 PropTypes로 props 구조를 명시하여 안정성 확보

