# 🎣 **React Hook이란?**

👉 **함수형 컴포넌트에 “상태(state)”와 “라이프사이클(side-effect)” 기능을 추가하기 위해, React가 제공하는 특별한 함수입니다.**

---

## 🎯 더 직관적인 설명

원래 함수형 컴포넌트는 단순히 “props → UI”만 만드는 **순수 함수**였습니다.

```jsx
function Hello() {
  return <h1>Hello</h1>;
}
```

여기서는

* 상태 없음
* 컴포넌트 생명주기 없음
* DOM 접근 불가
* 비동기 처리 없음

즉 **UI 출력만 가능한 순수한 함수**였죠.

---

## 🔥 그런데 앱을 만들면 이런 게 필요합니다:

* 클릭하면 숫자 증가 → **상태 필요**
* API 호출 → **사이드이펙트 필요**
* DOM 크기 측정 → **렌더 직후 작업 필요**
* 전역 데이터 공유 → **컨텍스트 필요**

이걸 **함수형 컴포넌트에서도 가능하게 만든 것**이 바로 **Hooks**입니다.

---

## 🧠 즉, Hook의 본질은 아래와 같습니다:

### ✔ **React 내부 상태 저장소에 접근할 수 있게 해주는 인터페이스**

예:<br>
`useState()` → 상태를 React에 저장<br>
`useReducer()` → 복잡한 상태 로직을 React에 저장<br>

### ✔ **렌더링 이후 특정 시점에 코드를 실행할 수 있게 하는 메커니즘**

예: <br>
`useEffect()` → 렌더 후 실행 <br>
`useLayoutEffect()` → DOM 반영 직후 실행 <br>

### ✔ **React 렌더링 엔진(Fiber)과 연결되는 특수한 함수**

Hooks는 React 렌더러가 관리하는 “Hook 메모리 슬롯”과 매칭됩니다.
그래서 **매번 같은 순서로 호출되어야 합니다.**

---

## ⚙️ 1. Hooks의 규칙 (Rules of Hooks)

React는 Hooks 사용 시 두 가지 규칙을 강력히 강제합니다.

#### 1️⃣ 반드시 **컴포넌트 최상위**에서만 호출해야 한다.

잘못된 예 ❌:

```js
if (isLogin) {
  const [count, setCount] = useState(0); // ❌ 오류 가능
}
```

React는 Hook을 호출한 순서대로 내부에 **Hook state 배열**을 저장합니다.
조건문/반복문 안에서 호출하면 순서가 달라져 React가 상태를 매칭할 수 없음.

#### 2️⃣ 반드시 **React 함수**(컴포넌트 또는 Custom Hook)에서만 호출해야 한다.

잘못된 예 ❌:

```js
function doSomething() {
  const [count, setCount] = useState(0); // ❌
}
```

---

## 🧩 2. React Hooks의 내부 동작 구조

React는 컴포넌트 렌더링 시 다음과 같은 “Hook Memory Slot”을 관리합니다.

```
FiberNode {
  memoizedState: Hook {
    memoizedState: any,       // 저장된 state 값
    queue: UpdateQueue,       // setState로 쌓인 업데이트 큐
    next: Hook | null         // 다음 Hook
  }
}
```

즉, 한 컴포넌트 안의 Hooks는 **연결 리스트(Linked List)** 형태로 저장됩니다.

렌더링이 일어날 때 React는 *Hook 호출 순서대로* 이 리스트를 읽어가며:

1. 이전 렌더링에서의 Hook 값 복구
2. 업데이트 큐 처리
3. 새 상태 계산
4. 다음 Hook 이동

바로 이것이 “Hook은 반드시 같은 순서”여야 하는 이유입니다.

---

## ⭐️ 3. 핵심 Hooks

---

### 🎯 useState — 상태 관리의 최소 단위

#### 📌 특징

* 초기 렌더링 시 `initialState` 평가
* 이후 렌더에서는 항상 memoizedState 사용
* 상태 업데이트는 **비동기 배치(batch)** 처리됨

#### 📌 예시

```js
const [count, setCount] = useState(0);
```

#### 📌 업데이트 방식

##### 1) 값 업데이트

```js
setCount(3);
```

##### 2) 함수 업데이트 (recommended)

```js
setCount(prev => prev + 1);
```

배치 업데이트에서 안전하며 여러 이벤트가 한꺼번에 처리될 때 레이스 컨디션 방지.

---

### 🎯 useEffect — 사이드 이펙트 처리

#### 📌 사이드 이펙트란?

* DOM 조작
* 서버 데이터 fetch
* 이벤트 리스너 등록
* 타이머 setTimeout

#### 📌 useEffect 동작 순서

1. 렌더링 → DOM 반영
2. effect 실행
3. 다음 렌더 시 cleanup 실행

#### 📌 예시

```js
useEffect(() => {
  const id = setInterval(() => console.log('tick'), 1000);
  return () => clearInterval(id);
}, []);
```

#### 📌 의존성 배열(deps)의 의미

* `[]` : 한 번만 실행
* `[value]` : value가 바뀔 때 실행
* 생략 : 모든 렌더링마다 실행

---

### 🎯 useLayoutEffect — 렌더 직후 DOM 계산 (동기)

#### useEffect 와의 차이

| Hook              | 시점                | 특징                   |
| ----------------- | ----------------- | -------------------- |
| ⭐ useEffect       | 화면이 그려진 후         | 비동기, UI 깜빡임 X        |
| ⭐ useLayoutEffect | DOM 계산 직후, 페인트 이전 | 동기 실행 → layout 측정 용도 |

DOM 사이즈 측정이 필요할 때 꼭 사용합니다.

---

### 🎯 useRef — 컴포넌트 렌더링과 독립적인 값 저장

#### 주요 사용 사례

1. DOM 요소 레퍼런스
2. 렌더링을 발생시키지 않는 상태 저장
3. setTimeout id 저장
4. 스크롤 위치 저장

```js
const inputRef = useRef(null);
```

---

### 🎯 useMemo — expensive 계산 결과 캐싱

```js
const value = useMemo(() => computeHeavy(a, b), [a, b]);
```

#### 사용 대상

* 연산 비용이 큰 함수
* 객체/배열 레퍼런스 유지 (memoized 컴포넌트 props 최적화)

---

### 🎯 useCallback — 함수 메모이제이션

```js
const onClick = useCallback(() => {
  console.log('clicked');
}, []);
```

#### 사용 목적

* 불필요한 자식 re-render 방지
* dependency 기반으로 함수 identity 유지

---

## 🎯 useReducer — 복잡한 상태 관리

Redux의 reducer 패턴을 컴포넌트 안에 내장한 구조.

```js
const [state, dispatch] = useReducer(reducer, initialState);
```

### 장점

* 다단계 상태 업데이트 로직 정리
* useState보다 예측 가능한 상태 흐름

---

### 🎯 useContext — 전역 수준의 의존성 주입

#### 사용 방식

```js
const ThemeContext = createContext();

function App() {
  return (
    <ThemeContext.Provider value="dark">
      <Page />
    </ThemeContext.Provider>
  );
}

function Page() {
  const theme = useContext(ThemeContext);
}
```

#### 특징

* 상태를 props drilling 없이 전달
* 단, 과도한 재렌더링 이슈 존재 → `memo + useMemo` 조합이 필요

---

## 🛠 4. Custom Hook — Hooks의 진짜 힘

Custom Hook을 사용하면 “상태 + 효과 + 함수”를 **모듈화**할 수 있습니다.

예: 스크롤 위치 감지 Custom Hook

```js
function useScrollY() {
  const [y, setY] = useState(0);

  useEffect(() => {
    const onScroll = () => setY(window.scrollY);
    window.addEventListener('scroll', onScroll);
    return () => window.removeEventListener('scroll', onScroll);
  }, []);

  return y;
}
```

사용:

```js
const y = useScrollY();
```

---

## 🚀 5. 실제 대규모 React 프로젝트에서 Hooks는 어떻게 쓰이나?

### ✔ 상태 로직 분리(SRP)

* 데이터 fetch → `useFetch`
* 폼 관리 → `useForm`
* WebSocket → `useWebSocket`
* IntersectionObserver → `useIntersection`

### ✔ 성능 최적화

* `useMemo`로 연산 최적화
* `useCallback`으로 핸들러 안정화
* `React.memo`로 자식 렌더 비용 절약

### ✔ 전역 상태 관리와 결합

* 리덕스 + useSelector (React Hooks)
* Zustand, Jotai 같은 Hook 기반 전역 상태 라이브러리

---

## 🔍 6. React Hooks와 렌더링 메커니즘 (심화)

### React는 다음 조건에서 렌더링을 발생

* state 변경
* parent props 변경
* context value 변경
* key 변경

Hooks들은 이 렌더링과 깊이 연결되어 있으며,
특히 **useEffect는 렌더링 이후에 실행되므로 UI = 렌더링 결과**가 먼저입니다.

---

## 🏁 7. Hooks의 잘못된 사용 패턴 (주의)

### 🚫 1) 불필요한 useEffect

```js
useEffect(() => {
  setValue(props.value);
}, [props.value]);
```

→ 이런 패턴은 대부분 잘못된 코드입니다. props를 state로 복사하는 것은 anti-pattern.

### 🚫 2) useMemo 남발

* 비용이 거의 없는 연산에 useMemo 쓰기
* deps가 매번 바뀌면 캐싱 자체가 의미 없음

### 🚫 3) useCallback 무조건 사용

* 자식 컴포넌트가 memoized 되어 있지 않다면 효과 없음

---

## 🧨 8. React 최신 버전의 Hook 동작 변화 (React 18 기준)

* 자동 배치 (Automatic Batching)
* Strict Mode의 double invocation
* concurrent rendering 기본 지원
* useTransition, useDeferredValue 등장

---

## 🎉 결론: Hooks는 React의 핵심 러닝 모델이다

React Hooks는 단순한 API가 아니라 React 앱의 **렌더링, 상태, 부수효과, 최적화** 전체를 아우르는 근본 개념입니다.

* 상태 관리 → useState, useReducer
* 부수효과 관리 → useEffect
* DOM 연동 → useRef, useLayoutEffect
* 최적화 → useMemo, useCallback
* 전역 의존성 → useContext
* 재사용 모듈화 → Custom Hooks

Hooks를 이해하면 React의 렌더링 메커니즘 전체가 보이게 됩니다.



