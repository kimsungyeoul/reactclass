리액트의 `useEffect`는 **“렌더링 이후에 일어나는 모든 부수 효과(side effect)를 관리하는 중심 Hook”** 입니다.
이걸 제대로 이해하면, **데이터 패칭, 구독, 타이머, DOM 조작, 로깅**까지 전부 “예측 가능하게” 다룰 수 있어요. 🤓

---

## 1. `useEffect`는 왜 필요한가? 🤔

리액트 함수 컴포넌트는 **“순수 함수”** 처럼 동작해야 합니다.

```
function MyComponent(props) {
  // ❌ 여기서 API 호출, setTimeout, DOM 조작, subscribe 등을 하면 안됨
  return <div>...</div>;
}
```

> 컴포넌트 내부에서 화면을 만드는 로직 외,
> **부수 효과는 렌더링 과정과 분리**되어야 함

하지만 실제 앱에서는 꼭 필요한 부수 효과들이 있습니다:

* 서버에서 데이터 가져오기 (fetch, axios)
* WebSocket / 이벤트 리스너 / 구독 등록
* `setTimeout`, `setInterval`, 애니메이션 시작
* DOM 직접 조작 (예: 외부 라이브러리 초기화)
* 로깅/통계 (페이지뷰, 버튼 클릭 등)

이 “렌더링 이후에 해야 할 작업”들을 **안전하게, 일관된 타이밍에** 실행하기 위해 생긴 것이 `useEffect`입니다.

---

## 2. 기본 문법과 개념 🧩

### 2-1. 기본 형태

```tsx
useEffect(() => {
  // ✅ 이 안에서 side effect 수행
  // 예: 데이터 패칭, 이벤트 등록, 타이머, 로깅 등

  return () => {
    // ✅ cleanup 함수
    // 예: 구독 해제, 타이머 정리, 이벤트 리스너 제거
  };
}, [/* 의존성 배열 */]);
```

각 부분의 의미:

* 첫 번째 아규먼트: `effect 함수`

  * 렌더링이 **DOM에 커밋(commit)된 이후** 호출
* 두 번째 아규먼트: `dependency array` (옵션)

  * **언제 effect를 다시 실행할지**를 리액트에게 알려주는 힌트
* 반환값: `cleanup 함수` (옵션)

  * effect가 **다시 실행되기 전 또는 컴포넌트 unmount 전**에 실행
 
```
// Fiber에 매달려 있는 패시브 이펙트 큐
// (실제 React는 fiber.updateQueue 안에 체인으로 둠)
function pushEffect(fiber, effect) {
  fiber.pendingPassiveEffects.push(effect);
}

// 의사 코드로 표현한 useEffect 내부 구현
function useEffect(create, deps) {
  const hook = getNextHook();            // 현재 위치의 Hook 슬롯 가져오기
  const fiber = currentlyRenderingFiber;
  const nextDeps = deps === undefined ? null : deps;

  if (hook.memoizedState === null) {
    // 🔹 [마운트 단계] 최초 렌더일 때
    const effect = createEffect(create, nextDeps);
    // "이번 커밋에서 반드시 실행해야 한다" 플래그 추가
    effect.tag |= EffectFlags.HasEffect;

    hook.memoizedState = effect;
    pushEffect(fiber, effect);
  } else {
    // 🔹 [업데이트 단계] 재렌더일 때
    const prevEffect = hook.memoizedState;
    const prevDeps = prevEffect.deps;

    // deps가 아예 없으면(=undefined) 항상 다시 실행
    // 또는 deps 배열 내용이 바뀐 경우
    if (nextDeps === null || !areHookInputsEqual(nextDeps, prevDeps)) {
      const effect = createEffect(create, nextDeps);
      // 이번 커밋에서 실행해야 함
      effect.tag |= EffectFlags.HasEffect;

      // 이전 destroy를 나중에 쓰려고 옮겨둘 수도 있음 (단순화를 위해 생략 가능)
      effect.destroy = prevEffect.destroy;

      hook.memoizedState = effect;
      pushEffect(fiber, effect);
    } else {
      // deps가 같으면 → effect는 그대로, 이번 커밋에서는 실행 안 함
      // (HasEffect 플래그도 없음)
      const effect = createEffect(create, prevDeps);
      effect.destroy = prevEffect.destroy;
      hook.memoizedState = effect;
      // 큐에 안 넣으니 커밋 때 실행 안 됨
    }
  }
}

```

---

## 3. 의존성 배열(dependency array)의 3가지 패턴 🔁

useEffect의 호출 여부는 deps 배열 변화 여부로만 결정된다

🎯 의존성 배열은 “언제 effect를 다시 실행할지”를 결정하는 조건표이다
```
useEffect(effectFn, [a, b, c])
```



### 3-1. 의존성 배열 없음: 매 렌더링마다 실행

```tsx
useEffect(() => {
  console.log('렌더링 이후 매번 실행');
});
```



* **모든 렌더링 후에 실행**
* 상태 업데이트를 여기서 무분별하게 하면 **무한 루프** 위험 🧨

```tsx
useEffect(() => {
  setCount(count + 1); // ❌ 매 렌더 후 실행 → 다시 렌더 → 또 실행...
});
```

이 패턴은 보통 **로깅, 단순 디버깅** 용도로나 잠깐 쓰는 정도가 좋습니다.
실전에서는 **거의 항상 의존성 배열을 사용하는 게 권장**됩니다.

---

### 3-2. 빈 배열 `[]`: 마운트/언마운트 시 한 번씩만

```
useEffect(() => {
  console.log('처음 마운트 될 때 한 번 실행');

  return () => {
    console.log('언마운트 될 때 한 번 실행');
  };
}, []);
```

* 클래스의 `componentDidMount` + `componentWillUnmount` 역할
* 사용 예:

  * 컴포넌트 초기화 (초기 데이터 fetch, 외부 라이브러리 init)
  * WebSocket 연결, 전역 이벤트 리스너 등록
  * **언마운트 시 정리 작업** (구독 해제, 타이머 정리 등)

---

### 3-3. 특정 값들에 의존 `[a, b, c]`

```tsx
useEffect(() => {
  console.log('searchTerm 또는 page가 바뀔 때마다 실행');

  fetchItems(searchTerm, page);

  return () => {
    console.log('다음 effect 실행 또는 언마운트 전에 정리');
  };
}, [searchTerm, page]);
```

이 의존성 배열[a, b, c]의 의미는 딱 하나입니다:
> a, b, c 중 하나라도 값이 바뀌면 effectFn을 다시 실행해라.
> 값이 안 바뀌면 실행하지 마라.


* `searchTerm` 또는 `page` 값이 바뀔 때만 effect 재실행
* 이전 렌더링에서의 값과 **“얕은 비교(shallow equal)”** 를 통해 변경 여부 판단
* 이 패턴은 클래스의 `componentDidUpdate`에 해당

> 🔑 핵심: **effect 안에서 사용하는 모든 외부 값은 의존성 배열에 넣는 것이 원칙**
> (규칙 위반 시 stale closure, 동기화 문제 발생)

---

## 4. 렌더링 사이클에서 `useEffect`의 위치 🧬

리액트 렌더링 파이프라인 (간단 버전):

1. **렌더 단계 (render phase)**

   * 컴포넌트 함수 호출 → JSX 리턴
   * 이 단계에서는 **DOM을 건드리면 안 됨** (순수 함수처럼)

2. **커밋 단계 (commit phase)**

   * React가 실제 DOM을 업데이트 (paint)

3. **Effect 단계**

   * 이때 `useEffect`들이 실행됨 (브라우저 paint 이후)

즉, `useEffect`는:

* **화면이 실제로 그려진 뒤에 실행**되기 때문에
* 화면 깜빡임을 유발하지 않고, 브라우저 렌더링을 막지 않음

> 참고: `useLayoutEffect`는 commit 후 **paint 이전** 에 동기적으로 실행됩니다.
> DOM 측정/레이아웃 계산이 필요한 특수한 경우에만 사용해야 하고,
> 대부분의 상황에서는 `useEffect`가 적절합니다.

---

## 5. cleanup 함수는 언제 호출될까? 🧹

```tsx
useEffect(() => {
  console.log('✅ effect 실행');

  return () => {
    console.log('🧹 cleanup 실행');
  };
}, [value]);
```

`cleanup`은 두 시점에 호출됩니다:

1. **다음 effect가 실행되기 직전**

   * `value`가 변경되어 effect 재실행이 필요할 때
   * 기존 effect와 관련된 리소스를 정리하기 위함

2. **컴포넌트 unmount 시**

   * 마지막 effect에 대한 cleanup이 호출

예를 들어 이벤트 리스너 등록/해제:

```tsx
useEffect(() => {
  function handleScroll() {
    console.log(window.scrollY);
  }

  window.addEventListener('scroll', handleScroll);
  console.log('📌 scroll 리스너 등록');

  return () => {
    window.removeEventListener('scroll', handleScroll);
    console.log('🧹 scroll 리스너 제거');
  };
}, []); // 한 번만 등록/해제
```

clean up을 제대로 하지 않으면:

* 이벤트 핸들러 중복 등록
* 메모리 누수
* 언마운트된 컴포넌트에서 상태 업데이트 시 경고 등 발생

---

## 6. `useEffect`와 클래스 라이프사이클 매핑 🔁

클래스 컴포넌트 시절 라이프사이클 메서드:

* `componentDidMount`
* `componentDidUpdate`
* `componentWillUnmount`

함수 컴포넌트에서 `useEffect`로 매핑하면:

```tsx
// componentDidMount
useEffect(() => {
  console.log('mount 시 한 번 실행');
}, []);

// componentDidUpdate (특정 값 변화에 반응)
useEffect(() => {
  console.log('count가 변할 때마다 실행');
}, [count]);

// componentWillUnmount
useEffect(() => {
  const id = setInterval(() => console.log('tick'), 1000);

  return () => {
    clearInterval(id);
  };
}, []);
```

**여러 개의 effect를 나누어 작성**할 수 있다는 것이 포인트입니다:

```tsx
function Profile({ userId }) {
  // 1) 데이터 패칭용 effect
  useEffect(() => {
    // fetch user
  }, [userId]);

  // 2) 구독용 effect
  useEffect(() => {
    // subscribe to notification
  }, [userId]);

  // 3) 페이지뷰 로깅용 effect
  useEffect(() => {
    console.log('Profile viewed');
  }, []);
}
```

클래스에서는 `componentDidMount/DidUpdate` 안에 여러 로직이 섞이지만,
`useEffect`에서는 **관심사별로 effect를 분리**할 수 있어 가독성이 좋아집니다. ✨

---

## 7. 자주 나오는 패턴들 🔧

### 7-1. 데이터 패칭 패턴 (fetch/axios)

```tsx
import { useEffect, useState } from 'react';

function UserList({ search }) {
  const [users, setUsers] = useState([]);
  const [loading, setLoading] = useState(false);

  useEffect(() => {
    let ignore = false;      // unmount 후 setState 방지용 패턴
    const controller = new AbortController();

    async function load() {
      setLoading(true);
      try {
        const res = await fetch(
          `/api/users?search=${encodeURIComponent(search)}`,
          { signal: controller.signal }
        );
        const data = await res.json();
        if (!ignore) {
          setUsers(data);
        }
      } catch (e) {
        if (!ignore) {
          console.error(e);
        }
      } finally {
        if (!ignore) {
          setLoading(false);
        }
      }
    }

    load();

    return () => {
      ignore = true;
      controller.abort(); // 요청 중단
    };
  }, [search]);

  // ...
}
```

포인트:

* `search`가 바뀔 때마다 새로운 요청
* cleanup에서:

  * `ignore = true`로 더 이상 `setState` 하지 않도록
  * `AbortController`로 진행 중인 fetch 중단

---

### 7-2. 타이머와 인터벌 관리

```tsx
useEffect(() => {
  const id = setInterval(() => {
    console.log('tick');
  }, 1000);

  return () => {
    clearInterval(id); // 🧹 꼭 정리!
  };
}, []); // 한 번만 등록
```

타이머를 만들면 **반드시 cleanup에서 clear** 해야 합니다.

---

### 7-3. 브라우저 이벤트 리스너

```tsx
useEffect(() => {
  const handleResize = () => {
    console.log(window.innerWidth);
  };

  window.addEventListener('resize', handleResize);

  return () => window.removeEventListener('resize', handleResize);
}, []); // 한 번만 등록·해제
```

---

## 8. `useEffect`가 자주 터뜨리는 버그들 🧨

### 8-1. 무한 렌더링 루프

```tsx
const [count, setCount] = useState(0);

useEffect(() => {
  setCount(count + 1);  // ❌ 의존성 배열 없음
});
```

* 렌더 → effect 실행 → `setCount` → 다시 렌더 → effect 실행 → …
* 결과: **무한 루프 + 성능 붕괴**

해결:

1. 의존성 배열을 추가하고,
2. effect 내부에서 state를 “업데이트 함수” 형태로 사용

```tsx
useEffect(() => {
  setCount(prev => prev + 1); // 그래도 dependency 없으면 한 번만? → ❌ 여전히 매번
}, []); // ✅ 이렇게 해야 마운트 시 딱 한 번만
```

---

### 8-2. 의존성 배열 누락 + stale closure 문제

```tsx
const [count, setCount] = useState(0);

useEffect(() => {
  const id = setInterval(() => {
    console.log(count);       // ⚠️ 이 count는 effect가 처음 실행될 때의 값으로 고정
    setCount(count + 1);      // 항상 같은 count 기준으로 +1
  }, 1000);
}, []); // ❌ count가 여기 없어요
```

* `[]`로 인해 effect는 한 번만 실행
* effect 내부의 `count`는 **첫 렌더 기준으로 캡처됨**
* 이후 `setCount`를 해도 effect 안의 `count`는 갱신되지 않음 → stale closure

해결 1: 의존성 배열에 `count` 추가 + cleanup

```tsx
useEffect(() => {
  const id = setInterval(() => {
    setCount(c => c + 1);  // 함수형 업데이트 권장
  }, 1000);

  return () => clearInterval(id);
}, []); // ✅ 함수형 업데이트를 쓰면 의존성 없이도 가능
```

**중요 패턴**:
state를 갱신할 때 **이전 값에 의존**한다면,
`setX(prev => 계산(prev))` 형태를 사용하면 의존성 배열에 굳이 `prev`를 넣지 않아도 됩니다.

---

### 8-3. 의존성 배열 자동 수정을 무시할 때

ESLint의 `react-hooks/exhaustive-deps` 룰 사용 시:

* effect 안에서 사용하는 값들을 자동으로 의존성 배열에 추천
* 이걸 억지로 무시하면 대부분 **버그로 이어짐**

```tsx
useEffect(() => {
  fetchData(userId); // userId를 사용함
}, []);              // ❌ userId 누락

// ESLint: userId를 dependency에 넣으라고 경고
```

대부분의 경우:

* ESLint가 말하는대로 의존성을 추가하는 것이 **정상적인 설계**
* 만약 정말 한 번만 실행해야 한다면,

  * 그 값이 **“정말로 변하지 않는 값”**이어야 함 (예: env 상수, 고정 config)

---

## 9. `useEffect`를 사용하면 안 되는 경우들 🚫

요즘 리액트 팀에서 강조하는 메시지:

> “**모든 것에 useEffect를 쓰지 마라**”

대표적으로:

1. **렌더링만으로 해결 가능한 것**에 effect 쓰지 않기

   * 예: `props`로부터 파생된 값을 `useState + useEffect`로 또 관리:

   ```tsx
   // ❌ 나쁜 예
   const [fullName, setFullName] = useState('');

   useEffect(() => {
     setFullName(firstName + ' ' + lastName);
   }, [firstName, lastName]);
   ```

   → 이런 건 그냥 **렌더링 중에 계산**하세요:

   ```tsx
   // ✅ 좋은 예
   const fullName = `${firstName} ${lastName}`;
   ```

2. **또 다른 상태를 “복사”해서 관리하는 effect** 피하기

   * derived state(파생 상태)는 effect보다 **계산식/메모이제이션(useMemo)**로 해결

3. **사용자 이벤트에 직접 반응하는 로직은 event handler에 두기**

   ```tsx
   // ❌ 버튼 클릭에 반응하는 걸 굳이 effect로 돌리기
   useEffect(() => {
     if (clicked) {
       doSomething();
     }
   }, [clicked]);

   // ✅ 그냥 이벤트 핸들러에서 처리
   const handleClick = () => {
     doSomething();
   };
   ```

`useEffect`는 **“렌더 이후, 외부 세계와 동기화를 맞춰야 할 때”** 쓰는 것이고,
순수한 계산/렌더링/이벤트 반응은 **effect 없이 처리**하는 것이 더 깔끔합니다.

---

## 10. `useEffect` vs `useLayoutEffect` ⚖️

짧게 비교해보면:

|        | useEffect           | useLayoutEffect                 |
| ------ | ------------------- | ------------------------------- |
| 실행 타이밍 | paint 이후 (비동기)      | DOM 커밋 직후, paint 이전 (동기)        |
| 목적     | 대부분의 side effect 작업 | 레이아웃 측정, DOM 기반 동기 업데이트 필요 시    |
| 성능 영향  | 브라우저 렌더링을 막지 않음     | 잘못 쓰면 렌더링 지연, 레이아웃 thrash 유발 가능 |
| 권장 빈도  | **기본 선택**           | 진짜 필요한 특수 케이스만                  |

**규칙**:

> “`useLayoutEffect`가 필요하다고 확신이 들 때까지는 항상 `useEffect`부터 쓰세요.”

---

## 11. SSR(서버 사이드 렌더링)과 `useEffect` 🌐

Next.js 같은 SSR 환경에서:

* `useEffect`는 **브라우저 환경에서만 실행**됩니다.
* 서버에서는 DOM도 없고 브라우저 API도 없기 때문에:

  * 서버 렌더링 중에는 effect가 호출되지 않음
  * 클라이언트에서 hydration 후에만 실행

즉, **SSR 환경에서 브라우저 전용 로직**(window, document, localStorage 등)을 쓸 때도
`useEffect` 안에 넣어두면 안전합니다.

```tsx
useEffect(() => {
  // SSR 중에는 실행 X, 클라이언트에서만 실행
  const stored = localStorage.getItem('theme');
  // ...
}, []);
```

---

## 12. 정리: `useEffect`를 잘 쓰기 위한 체크리스트 ✅

마지막으로, 강의/실무에서 학생/동료에게 강조해줄만한 체크 포인트를 정리해볼게요.

1. **effect 안에는 “렌더링 후에 해야 할 일”만 넣기**

   * 데이터 패칭, 구독, 타이머, DOM 조작, 로깅 등
2. **의존성 배열을 항상 의식하기**

   * effect 내부에서 사용하는 값들 = 기본적으로 dependency에 넣기
   * state 이전 값에 의존하는 경우는 “함수형 업데이트” (`setX(prev => ...)`) 적극 활용
3. **cleanup을 꼼꼼히 작성하기**

   * 이벤트 리스너, 타이머, 구독 등은 반드시 정리
4. **무한 루프에 주의**

   * `dependency` 없는 effect에서 `setState` 호출은 특히 조심
5. **derived state는 effect로 만들지 말 것**

   * 계산 가능한 값은 렌더링 중 계산 or `useMemo`
6. **이벤트 반응 로직은 이벤트 핸들러 안에**

   * `onClick`, `onChange` 등에서 직접 처리
7. **useLayoutEffect는 정말 필요한 경우에만**

   * 레이아웃 측정/동기 DOM 업데이트 상황이 아니라면 `useEffect` 사용


