# 🌟 JSX의 `ref` — DOM 접근부터 React 내부 흐름까지

React에서 `ref`는 **DOM 요소나 React 컴포넌트 인스턴스를 직접 참조하기 위한 공식적인 방식**입니다.
하지만 JSX에서 ref를 사용하는 문법, 호출 시점, 내부 동작 방식은 충분히 깊게 이해하지 않으면 헷갈리기 쉽습니다.

아래에서 **JSX의 ref 문법 → React Fiber 트리를 따라 ref가 연결되는 과정 → useRef와의 관계 → 함수형 컴포넌트의 ref 제한사항 → forwardRef까지** 모두 설명해드리겠습니다.

---

# 1️⃣ JSX에서 ref를 사용하는 기본 문법

## ✔ DOM 요소에 ref

```jsx
function MyComponent() {
  const inputRef = useRef(null);

  return (
    <input ref={inputRef} />
  );
}
```

JSX에서 `ref={someRef}` 형태로 전달하면 React는 **해당 DOM 노드를 thisRef.current에 넣어줍니다.**

즉 **JSX의 ref 속성은 특별한 예약어**이며 일반 props처럼 동작하지 않습니다.

---

# 2️⃣ JSX에서 ref는 왜 특별한가?

🧠 **중요 포인트:**
`ref`는 **props로 전달되지 않습니다.**

예:

```jsx
<MyInput ref={inputRef} />
```

➡ **MyInput(props)에서 props.ref로 받을 수 없습니다.**

왜냐하면:

* React는 ref 속성을 잡아서 내부에서 직접 처리합니다.
* 일반 props로 내려가지 않습니다.

---

# 3️⃣ 함수형 컴포넌트는 ref를 받을 수 없는 이유

```jsx
function MyButton() {
  return <button>Click</button>;
}

<MyButton ref={btnRef} />
```

❌ **ref가 MyButton으로 전달되지 않습니다.**
React는 **함수형 컴포넌트에 인스턴스가 없기 때문**에 ref를 연결하지 않습니다.

⛔ 그래서 에러 발생:

> Function components cannot be given refs.

👉 이 문제를 해결하는 공식 API가 바로 **`forwardRef`** 입니다.

---

# 4️⃣ forwardRef로 ref를 명시적으로 전달하기

```jsx
const MyInput = React.forwardRef((props, ref) => {
  return <input ref={ref} />;
});
```

이제 사용 가능:

```jsx
const inputRef = useRef(null);

<MyInput ref={inputRef} />;
```

---

# 5️⃣ JSX에서 ref의 두 가지 형태

JSX는 ref를 두 가지 형태로 허용합니다.

## ① 객체 ref (`useRef`, `createRef`)

```jsx
const myRef = useRef();
<div ref={myRef} />;
```

## ② 콜백 ref

```jsx
<div ref={el => console.log('DOM:', el)} />
```

콜백 ref는 다음 상황에 유용합니다:

* DOM 노드 변화 감지
* unmount 시점 감지
* 외부 라이브러리 연동

---

# 6️⃣ React 내부에서 ref가 연결되는 전체 과정 (Fiber 기반)

여기서는 “JSX → Fiber → commit → ref 연결”의 흐름을 완전하게 설명드립니다.

## 📌 1단계: JSX 파싱

```jsx
<input ref={someRef} />
```

JSX는 다음으로 변환됩니다.

```js
React.createElement('input', { ref: someRef })
```

## 📌 2단계: Fiber 생성 중 ref 정보 저장

React는 해당 element를 기반으로 **Fiber node**를 생성합니다.

Fiber에는 다음 정보가 저장됩니다:

* `pendingProps.ref`
* `ref` 필드

즉 **Fiber 구조 안에 ref가 보존됩니다.**

## 📌 3단계: commit 단계에서 ref가 실제 DOM 유효화

commitPhase → layout effects 단계에서
DOM이 생성되면 React는 다음 작업을 수행합니다:

### 📌 객체 ref일 경우:

```js
ref.current = domNode;
```

### 📌 콜백 ref일 경우:

```js
ref(domNode);
```

📌 **unmount 시점**

* 객체 ref → `ref.current = null`
* 콜백 ref → `ref(null)` 호출

즉 React는 LifeCycle에 맞춰 ref를 설정/해제합니다.

---

# 7️⃣ useRef와 JSX ref는 어떤 관계인가?

`useRef`는 ref 객체를 생성하는 훅일 뿐입니다:

```js
const myRef = { current: null };
```

JSX에 넘기면 React가 DOM node를 할당해주는 것입니다.

---

# 8️⃣ ref가 업데이트되는 시점

ref는 **렌더 → commit → layoutEffect 전**에 DOM이 주입됩니다.

⏱ ref 업데이트 순서:

1. DOM 생성됨
2. ref 연결됨 (`ref.current = DOM`)
3. layoutEffect 실행 (`useLayoutEffect`)
4. 그 후 useEffect 실행

즉 ref는 **useLayoutEffect 내부에서 항상 최신값 보장**됩니다.

---

# 9️⃣ ref 사용 시 주의해야 할 점

### 🔥 1. ref 값 변경은 리렌더를 일으키지 않음

```js
ref.current = 123;
```

➡ 상태 업데이트가 아니므로 컴포넌트가 다시 렌더되지 않습니다.

### 🔥 2. 함수형 컴포넌트는 ref 대상이 아님

반드시 forwardRef 사용.

### 🔥 3. ref를 조건문으로 배치하면 DOM 연결이 깨질 수 있음

---

# 🔥 10️⃣ 고급: class 컴포넌트에서의 ref 동작

class 컴포넌트는 인스턴스를 갖기 때문에 ref가 곧 인스턴스를 가리킵니다.

```jsx
class Modal extends React.Component {}
const ref = React.createRef();

<Modal ref={ref} />
```

`ref.current` → Modal 인스턴스
✔ setState
✔ 메서드 호출 가능

함수형 컴포넌트에는 인스턴스 없음 → ref 불가

---

# 11️⃣ 고급: ref는 props처럼 key와 함께 특별 취급됨

JSX의 key도 props로 전달되지 않습니다.

| 속성    | props로 전달? | React 내부에서 특별 처리? |
| ----- | ---------- | ----------------- |
| props | ✔          | ❌                 |
| key   | ❌          | ✔                 |
| ref   | ❌          | ✔                 |

즉 ref는 JSX의 **예약된 특수 어트리뷰트**입니다.

---

# 12️⃣ 실제 useRef와 ref 연결 완전 예제

```jsx
import { useRef, useEffect } from "react";

export default function App() {
  const boxRef = useRef(null);

  useEffect(() => {
    console.log("mounted:", boxRef.current); // DOM node
    boxRef.current.style.backgroundColor = 'yellow';
  }, []);

  return (
    <div>
      <h1>Ref Test</h1>
      <div
        ref={boxRef}
        style={{ width: 200, height: 100, background: '#eee' }}
      />
    </div>
  );
}
```

---

# 🎯 결론

### ✔ JSX의 ref는 props가 아니다 — React가 직접 처리한다

### ✔ Fiber commit 단계에서 DOM 생성 후 ref 연결

### ✔ 함수형 컴포넌트는 ref를 받을 수 없다 → forwardRef 필요

### ✔ 객체 ref / 콜백 ref 두 종류

### ✔ ref는 렌더링 트리거가 되지 않는다

### ✔ key와 함께 특별한 JSX 어트리뷰트이다
