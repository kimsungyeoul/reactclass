## 1. React Fiber란 무엇인가? 🧵

### 1-1. “Fiber = 리액트의 가벼운 작업 단위 + 노드 구조”

공식적으로 Fiber는:

> **“React의 새로운 reconciliation(비교) 알고리즘 및 내부 아키텍처”**

이지만, 더 구체적으로 말하면:

* **DOM 노드 / 컴포넌트 인스턴스를 표현하는 노드 구조체**
* 동시에 **작업 단위(unit of work)** 이기도 함
* 이 노드들로 이루어진 트리를 우리는 **Fiber Tree**라고 부름

그러니까 Fiber는:

> “리액트가 어떤 컴포넌트가 무엇을 렌더링하는지, 어떤 상태를 가지는지, 다음에 무엇을 업데이트해야 하는지”를 담는 내부 데이터 구조

라고 이해하시면 됩니다.

---

## 2. 왜 Fiber가 등장했는가? (기존 Stack Reconciler의 한계) 🧨

### 2-1. 옛날 React(15 이하)의 문제

React 15 시절에는 Reconciliation이 대략 이런 느낌이었습니다:

1. 상태가 바뀐다 → 전체 트리를 재귀적으로 내려가면서 비교
2. 한 번 시작된 작업은 **중간에 멈출 수 없음**
3. 트리가 크고 연쇄적인 업데이트가 많으면
   → **메인 스레드를 오래 점유**
   → 입력 렉, 스크롤 끊김, 애니메이션 끊김

즉, 예전 리액트는 렌더 중에:

> “잠깐만, 사용자 입력 좀 먼저 처리하고 다시 렌더할게”

를 할 수 없었습니다.

### 2-2. Fiber의 목표

Fiber는 이런 목표를 갖고 설계되었습니다:

1. **작업 쪼개기**: 큰 렌더 작업을 작은 단위(=Fiber)로 나눔
2. **우선순위**: 중요한 작업(사용자 입력, 애니메이션)을 덜 중요한 작업(저우선 렌더링)보다 먼저 처리
3. **협조적 스케줄링(cooperative scheduling)**: 브라우저에게 CPU를 양보했다가 다시 이어서 작업
4. **중단/재개/취소 가능**: 렌더 도중에 “잠깐 멈췄다가 이어서” 혹은 “이거 필요 없네, 버려” 가능

결국 Fiber는:

> “렌더를 한 번에 끝까지 밀어붙이지 말고, 잘게 잘라서 상황 봐가며 조금씩 처리하자”

를 위한 아키텍처입니다. ⏱️

---

## 3. Fiber Node의 구조: 안에 뭐가 들어있나? 🧱

Fiber 노드는 JS 객체(혹은 구조체)에 불과합니다.
(아래 코드는 실제 구현과 1:1은 아니지만 개념 이해용입니다.)

```js
type Fiber = {
  // 어떤 타입의 컴포넌트/노드인가
  tag: WorkTag;             // FunctionComponent, ClassComponent, HostComponent(div/span) 등
  type: any;                // 실제 컴포넌트 함수, 클래스, 'div' 같은 문자열

  // 키/식별자
  key: null | string;

  // 트리 구조
  child: Fiber | null;      // 첫 번째 자식
  sibling: Fiber | null;    // 옆 형제
  return: Fiber | null;     // 부모

  // 상태/props
  pendingProps: any;        // 이번 렌더에 사용될 props
  memoizedProps: any;       // 이전 렌더에 사용했던 props
  memoizedState: any;       // Hook 상태/클래스 state 등

  // 업데이트 관련
  updateQueue: any;         // setState/useState 업데이트 큐
  lanes: Lanes;             // 이 Fiber에 걸린 작업 우선순위 정보

  // 이중 버퍼링을 위한 연결
  alternate: Fiber | null;  // 현재 트리와 workInProgress 트리를 잇는 페어

  // DOM 연결
  stateNode: any;           // 실제 DOM 노드 or 클래스 인스턴스

  // commit 단계에서 해야 할 일(플래그/이펙트)
  flags: Flags;
  subtreeFlags: Flags;
};
```

핵심 포인트만 정리하면:

* **트리 구조**: `child`, `sibling`, `return` 포인터로 부모-자식-형제 관계 표현
* **상태 저장**: `memoizedState`, `memoizedProps` 등에 컴포넌트의 상태/이전 props 저장
* **DOM 연결**: `stateNode`가 실제 DOM 노드(or 클래스 인스턴스)를 가리킴
* **우선순위/작업 정보**: `lanes`, `flags` 등을 통해 현재 Fiber에 어떤 작업이 걸려 있는지 표현
* **alternate**: **현재 트리(current)** 와 **작업 중 트리(workInProgress)** 를 연결

---

## 4. Fiber Tree & Double Buffering 🌲🌲

리액트는 렌더링 시 **두 개의 Fiber 트리**를 사용합니다:

1. **current tree (현재 화면을 나타내는 트리)**
2. **workInProgress tree (새로 계산 중인 트리)**

각 Fiber 노드는 `alternate` 필드를 통해 자기 짝을 가리킵니다.

* `currentFiber.alternate === workInProgressFiber`
* `workInProgressFiber.alternate === currentFiber`

렌더링 과정:

1. 업데이트 발생 → `workInProgress` 트리를 만든다.

   * 기존 `current` 트리를 참고하면서, 변경사항만 반영한 새 Fiber들을 구성
2. 작업이 끝나고 commit 단계에 도달하면

   * `workInProgress`를 **새로운 current로 스왑**
   * 즉, 화면이 한 번에 새로운 트리로 교체됨

이 방식 덕분에:

* 렌더 도중에는 **현재 화면은 그대로 안정적**
* 작업이 완전히 끝난 시점에만 화면이 한 번에 바뀜 → UI 일관성 유지 👌

---

## 5. React Fiber의 렌더링 파이프라인: Render Phase vs Commit Phase ⚙️

React Fiber의 업데이트는 크게 두 단계로 나뉩니다.

### 5-1. Render Phase (재조정 / work loop) 🎢

* 목표: **새로운 Fiber 트리(workInProgress)를 계산**
* 특징:

  * 순수 함수처럼 → **DOM을 실제로 건드리지 않음**
  * 중단 가능 / 재개 가능
  * 우선순위 기반으로 작업 스케줄 조정 가능

주요 작업:

1. 어떤 Fiber에서부터 업데이트를 시작할지 결정 (root에서 시작)
2. `beginWork` (자식 계산) → `completeWork` (자신 마무리) 를 반복하며 트리 순회
3. 각 Fiber에 “이 Fiber는 나중에 DOM을 어떻게 바꿔야 하는지”를 나타내는 **flags** 설정

   * `Placement` (새로 추가)
   * `Update` (수정)
   * `Deletion` (삭제)
4. Effect list(커밋해야 할 일 목록)를 구성

### 5-2. Commit Phase (실제 DOM 조작) 🧱

* 목표: Render phase에서 계산된 결과를 **실제로 DOM에 반영**
* 특징:

  * **중단 불가** (한 번 시작되면 끝까지)
  * 최대한 빨리 끝내려고 설계
* 작업 단계:

  1. **before mutation** (DOM 변경 전): `getSnapshotBeforeUpdate` 등 호출
  2. **mutation** (DOM 변경): DOM 생성/삭제/속성 변경 등 반영
  3. **layout** (DOM 변경 후): `useLayoutEffect`, 클래스의 `componentDidMount/Update` 등 실행

정리하면:

> Render Phase: “어떻게 바꿀지 계획 세우기”
> Commit Phase: “실제로 DOM에 적용하기”

---

## 6. 스케줄링과 우선순위: Lanes 🎯

Fiber의 강점 중 하나는 **스케줄링**입니다.

### 6-1. 예전 priority 모델 → Lanes로 진화

초기 Fiber는 단일 priority 기반(High, Low 등)이었지만,
현재는 **Lanes**라는 비트마스크 기반의 우선순위 시스템을 사용합니다.

* 각 업데이트에 lane(차선)을 부여
* 여러 lane이 동시에 존재 가능
* 중요한 lane(입력, 전환)은 빠르게 처리
* 덜 중요한 lane(배경 데이터 로딩)은 뒤로 미룸

이는 `startTransition` 같은 API가 사용하는 기반입니다.

```jsx
const [value, setValue] = useState('');
const [list, setList] = useState([]);

function handleChange(e) {
  setValue(e.target.value);            // 즉시/높은 우선순위 업데이트
  startTransition(() => {
    setList(heavyFilter(e.target.value)); // 낮은 우선순위 업데이트
  });
}
```

* 입력 응답성은 유지
* 무거운 렌더는 background에서 처리 → Fiber + Lanes 덕분 💡

---

## 7. Reconciliation: Fiber가 children을 어떻게 비교하나 🔍

Fiber는 기존 “Diff 알고리즘”을 기반으로 다음 원칙으로 children을 비교합니다:

1. **타입이 같고 key도 같으면** → 기존 Fiber 재사용, props만 업데이트
2. **타입이 다르거나 key가 다르면** → 기존 Fiber는 삭제, 새 Fiber 생성
3. 리스트에서 key를 활용하여:

   * 요소 이동/삽입/삭제를 최소화

예:

```jsx
<ul>
  {items.map(item => (
    <li key={item.id}>{item.text}</li>
  ))}
</ul>
```

이 경우:

* `key={item.id}` 덕분에
* Fiber는 이전 렌더와 비교 시 같은 `id`를 가진 li의 Fiber를 재사용
* 순서가 바뀌어도 “같은 요소”로 인식

즉, Fiber 수준에서 “어느 노드를 유지/삭제/생성할지” 결정하는 핵심 기준이 **type + key** 입니다.

---

## 8. Hook과 Fiber: memoizedState의 정체 🧬


> “React는 각 컴포넌트를 Fiber로 관리합니다”
> “memoizedState는 뭐냐?”

### 8-1. 함수 컴포넌트와 Fiber

함수 컴포넌트는 클래스 인스턴스가 없기 때문에,
리액트는 **Fiber 노드 안에 Hook 상태를 저장**합니다.

* `fiber.memoizedState` : 첫 번째 Hook을 가리키는 **연결 리스트의 head**
* 각 Hook은 이런 식의 노드 구조로 연결됩니다:

```js
type Hook = {
  memoizedState: any; // useState 값, useReducer state, useRef 객체 등
  baseState: any;
  baseQueue: Update | null;
  queue: UpdateQueue | null;
  next: Hook | null;  // 다음 Hook
};
```

Fiber 레벨:

```js
fiber.memoizedState -> Hook1 -> Hook2 -> Hook3 -> ...
```

그래서 **Hook 호출 순서가 중요**합니다:

* 첫 번째 `useState` → 첫 번째 Hook 노드
* 두 번째 `useEffect` → 두 번째 Hook 노드
* … 순서가 바뀌면 완전히 다른 Hook에 매핑되어 버림 → React가 경고하는 이유

### 8-2. 렌더 단계에서의 Hook 동작

React가 함수 컴포넌트를 렌더할 때:

1. Fiber를 “현재 렌더 중인 Fiber”로 지정
2. `currentlyRenderingFiber.memoizedState`에서 Hook 리스트를 읽기 시작
3. 컴포넌트 함수 안에서 `useState`, `useEffect` 등을 호출할 때마다:

   * 현재 Hook 포인터를 이동
   * 해당 Hook 노드의 `memoizedState`를 반환하거나, 새로 만들거나, 업데이트
4. 렌더가 끝나면 새 Hook 리스트가 `fiber.memoizedState`에 저장

즉,

> **Hook 메모리 슬롯** = Fiber 안의 Hook 연결 리스트 노드들

이고,

> **컴포넌트 당 Fiber가 하나씩 있고, 그 Fiber마다 자기 Hook 슬록(리스트)을 갖고 있다**


---

## 9. Effects와 Fiber: useEffect / useLayoutEffect 🧠

Effect도 Fiber에 플래그와 리스트 형태로 연결됩니다.

* `useEffect` 호출 시:

  * Hook 노드에 effect 정보 등록
  * Fiber의 flags에 “이 Fiber에는 passive effect가 있다” 표시
* Commit phase에서:

  1. mutation 이후
  2. 별도의 pass에서 `useEffect`들을 순회하며 실행/cleanup

`useLayoutEffect`는:

* DOM 변경 직후, paint 전에 실행되도록
* Commit phase 내에서 별도의 타이밍에 실행

이 모든 정보는 결국 **Fiber와 그 Hook 리스트에 붙은 메타데이터**에 저장되어 있습니다.

---

## 10. Fiber와 Concurrent Features (동시성 기능) ⏳

Concurrent Mode(현재는 공식 문서에서는 “Concurrent Features” 느낌으로 부분적으로 제공)는
**Fiber 없이는 구현이 거의 불가능**합니다.

* 렌더 작업을 **쪼개고**
* 우선순위를 지정하고
* 중간에 **yield(양보) / resume(재개)** 하며
* 필요하면 **버리고 다시 시작**

하는 모든 능력이 바로 Fiber 아키텍처의 본질입니다.

대표적인 concurrent 관련 기능들:

* `startTransition`
* `Suspense` (데이터 로딩 지연 처리)
* selective hydration 등

모두 Fiber의 **스케줄링 + 이중 버퍼링 + 우선순위** 덕을 보고 있습니다.

---

## 11. 요약 정리 🧾

1. **Fiber는 React 내부의 “작업 단위 + 노드 구조”**

   * 컴포넌트/DOM 노드/상태/이펙트/우선순위 정보를 담는 객체
2. **Fiber Tree는 UI의 구조를 표현하는 내부 트리**

   * `child`, `sibling`, `return` 포인터로 연결
3. **Double Buffering으로 current vs workInProgress 트리를 동시에 관리**

   * render phase에서 workInProgress 트리를 계산
   * commit phase에서 한 번에 DOM에 반영
4. **Render Phase는 중단/재개 가능, Commit Phase는 불가**

   * Render = 계획 세우기
   * Commit = 실제 DOM 업데이트
5. **Lanes로 우선순위를 제어해서 사용자 입력/애니메이션 반응성 보장**
6. **Reconciliation에서 type + key로 children을 비교**

   * key가 올바르게 잡혀야 효율적 업데이트 가능
7. **Hook 상태는 Fiber의 memoizedState(연결 리스트)로 관리**

   * 컴포넌트마다 Fiber가 있고, 그 안에 Hook “슬롯” 리스트가 있음
   * Hook 호출 순서가 중요한 이유
8. **Effects(useEffect/useLayoutEffect)는 Fiber의 effect 리스트로 관리**

   * Commit 단계에서 알맞은 타이밍에 실행
9. **Concurrent Features는 Fiber 덕분에 가능**

   * 작업 쪼개기, 스케줄링, 우선순위, 중단/재개

---

## 12. 정리 🎤

> “컴포넌트 하나당 Fiber 노드가 하나 있고, 그 Fiber 안에
> 상태(Hook), 이펙트, DOM 연결, 부모/자식/형제 관계, 우선순위 정보가 모두 들어있다.
> React는 이 Fiber 트리를 조금씩 수정해가면서, 필요할 때만 DOM을 바꾸는 엔진이다.”


