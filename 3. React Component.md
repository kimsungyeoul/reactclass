

# ✅ React Component

---

# 🚀 React 컴포넌트: 웹 UI를 구성하는 최소 단위의 모든 것

React 애플리케이션을 구성하는 가장 중요한 요소가 무엇인지 물으면, 단연 **컴포넌트(Component)** 입니다.
컴포넌트는 React 세계의 **원자(atom)** 이며, 모든 UI는 컴포넌트를 조합해 구성합니다.


---

# 🎯 1. 컴포넌트란 무엇인가?

## 💡 컴포넌트(Component)의 핵심 정의

React 컴포넌트는 **UI의 한 조각을 반환하는 자바스크립트 함수**입니다.

✨ 한 문장으로 표현하면:

> **하나의 입력(props)를 받아서 React Element(=UI)를 반환하는 순수 함수 같은 존재**

---

# 🧱 2. 컴포넌트의 기본 형태

React 컴포넌트는 두 가지 방식으로 정의할 수 있습니다.

## ① 함수형 컴포넌트(Function Component) – 현대 React의 표준 👍

```jsx
function Welcome({ name }) {
  return <h1>Hello, {name}!</h1>;
}
```

* Hooks 사용 가능
* 상태(state), 사이드이펙트(useEffect), 메모이제이션(useMemo/useCallback) 가능
* 가장 널리 사용되는 형태

## ② 클래스형 컴포넌트(Class Component) – 레거시

```jsx
class Welcome extends React.Component {
  render() {
    return <h1>Hello, {this.props.name}!</h1>;
  }
}
```

* 과거에는 LifeCycle 메서드 중심
* 지금은 Hooks 등장 이후 거의 사용하지 않음

👉 **2024년 이후 React 공식 문서의 방향성은 함수형 컴포넌트가 Only Standard입니다.**

---

# 📦 3. React 컴포넌트는 입력과 출력이 명확하다

## 📝 입력(Input): Props

Props는 부모 → 자식으로 전달하는 **읽기 전용 값**입니다.

```jsx
<Card title="Profile" theme="dark" />
```

Props는 객체로 전달됩니다:

```jsx
function Card({ title, theme }) {
  return <div className={theme}>{title}</div>;
}
```

---

## 🎨 출력(Output): React Element

React 컴포넌트는 **JSX로 표현된 React Element를 반환**합니다.

```jsx
return <h1>Hello!</h1>;
```

React는 이 요소를 기반으로 **가상 DOM(Virtual DOM)**을 생성하고 실제 DOM을 업데이트합니다.

---

# 🧠 4. React 컴포넌트는 순수함수를 지향한다

컴포넌트는 다음 조건을 지키는 것이 이상적입니다:

* 입력(props)이 같으면 같은 결과(UI)를 렌더링한다.
* 렌더링 과정에서 DOM을 직접 조작하지 않는다.
* 렌더링 중 외부 상태를 바꾸지 않는다.

그래서 React는 외부 상태 변경을 **Hook(예: useState)**에 의해서만 가능하도록 제한합니다.

---

# 🧩 5. JSX는 컴포넌트의 문법적 핵심

React 컴포넌트는 **JSX**로 작성됩니다.

JSX는 HTML처럼 보이지만 사실:

```
JSX → React.createElement() 호출 → React Element 생성
```

예:

```jsx
<div className="box">Hello</div>
```

컴파일 후:

```js
React.createElement("div", { className: "box" }, "Hello");
```

---

# 🔄 6. 컴포넌트의 렌더링 과정 (VDOM 기반)

React 컴포넌트는 아래 흐름으로 렌더링됩니다:

1. 컴포넌트 함수 실행
2. JSX → React Element 생성
3. Virtual DOM 트리 구성
4. 이전 VDOM과 비교 (Reconciliation)
5. 변경된 부분만 실제 DOM 패치

🧠 이 전 과정은 React의 **Fiber 엔진**이 처리합니다.

---

# 🔌 7. Props와 Children: 컴포넌트의 구성요소

## ① 명시적 props

```jsx
<Card title="Profile" foo={123} />
```

→ title, foo가 props 객체로 전달됩니다.

## ② 암묵적 props: children

```jsx
<Card>
  <UserProfile />
  <ActionButtons />
</Card>
```

→ 자식 노드들이 자동으로 `props.children`에 담깁니다.

---

# 🔐 8. 컴포넌트는 “상태(state)”를 가질 수 있다

React에서 동적인 UI의 중심은 **state**입니다.

```jsx
function Counter() {
  const [count, setCount] = useState(0);
  return (
    <button onClick={() => setCount(count + 1)}>
      클릭: {count}
    </button>
  );
}
```

State의 특징:

* 컴포넌트 내부에서만 관리
* 값 변경 시 컴포넌트가 자동 리렌더링
* 부모 → 자식으로 전달해야 할 경우 props로 내려주기

---

# 🔁 9. 컴포넌트 재사용 패턴

컴포넌트를 잘 설계하면 재사용성과 유지보수성이 높아집니다.

## 🎛️ 1) Presentational & Container Component 패턴

UI(프레젠테이션)과 로직(컨테이너)을 분리

## 🎨 2) Composition (조합)

React의 가장 핵심 패턴

```jsx
<Card>
  <Header />
  <Content />
</Card>
```

## 🧲 3) Render Props

```jsx
<DataProvider render={data => <Chart data={data} />} />
```

## 🎬 4) Custom Hooks

로직 재사용의 표준 방식

```jsx
function useFetch(url) { ... }
```

---

# ⚙️ 10. 고급 렌더링 최적화

## 🎯 memo

props가 같으면 렌더링 스킵

```jsx
export default React.memo(MyComponent);
```

## 🎯 useCallback

함수 재생성 방지

## 🎯 useMemo

비싼 계산 메모이제이션

## 🎯 Suspense / Lazy Loading

코드 스플리팅 + 지연 렌더링

---

# 🎮 11. 이벤트 처리

React의 이벤트는 **SyntheticEvent(합성 이벤트)** 기반입니다.

```jsx
<button onClick={handleClick}>Click</button>
```

* React 내부에서 모든 이벤트는 최상위 레벨에서 관리
* 버블링 전략이 DOM과 99% 동일
* 이벤트 객체가 SyntheticEvent로 래핑됨

---

# 🧬 12. 컴포넌트의 라이프사이클 (Hooks 버전)

## Mount(초기 렌더링)

* useEffect(() => {...}, [])

## Update(변경 렌더링)

* useEffect(() => {...}, [의존성])

## Unmount(제거)

* useEffect(() => { return () => {...} }, [])

---

# 🏁 13. 실전 예제: 전문가 버전 Card 컴포넌트

```jsx
function Card({ title, children }) {
  return (
    <div className="card">
      <h2>{title}</h2>
      <section>{children}</section>
    </div>
  );
}
```

사용:

```jsx
<Card title="Profile">
  <UserProfile />
  <ActionButtons />
</Card>
```

### 👉 문법적 의미

* `<Card title="Profile">` → **JSX Attribute 문법**
* `<UserProfile />` → React Element
* 내부 요소 전체 → **JSX Children 문법**
* children은 props의 일부로 자동 전달됨

---

# 🧨 14. 결론

React 컴포넌트는 단순한 UI 조각이 아니라:

* 입력과 출력이 분리된 순수함수적 구조
* Virtual DOM 기반 렌더링의 핵심
* 상태와 로직을 담는 핵심 단위
* 조합을 통한 무한 확장성의 기반
* Hooks를 통해 강력하게 재사용 가능한 단위

즉, **React 애플리케이션의 모든 것은 컴포넌트로 시작해 컴포넌트로 끝난다**고 할 수 있습니다. 🌟


