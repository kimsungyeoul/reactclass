리액트에서 “메모이제이션(Memoization)”은
**“쓸데없는 일(불필요한 연산/렌더링)을 다시 하지 않게 막는 기술”** 입니다. 🙂

특히 리액트는 **상태가 바뀔 때마다 함수 컴포넌트를 다시 호출**하기 때문에,
메모이제이션을 이해하면 **성능·구조·버그** 세 마리 토끼를 한 번에 잡을 수 있습니다.

아래에서는

1. 메모이제이션 일반 개념 🧠
2. 리액트 렌더링 특성과 왜 메모이제이션이 필요한지 🔁
3. `React.memo` 깊게 보기 🧱
4. `useMemo` 깊게 보기 📦
5. `useCallback` 깊게 보기 🎣
6. 내부적으로 어떻게 동작하는지(hook.memoizedState와 연결) ⚙️
7. 언제 쓰고, 언제 쓰지 말아야 하는지 체크리스트 ✅

까지 정리해 보겠습니다.

---

## 1. 메모이제이션이란 무엇인가? 🧠

일반적인 프로그래밍에서 메모이제이션은:

> **같은 입력에 대해 같은 연산을 반복하지 않고,
> 한 번 계산해 놓은 결과를 어딘가에 저장해 두었다가 다시 재사용하는 것**

의미입니다.

예를 들어, 순수 자바스크립트에서:

```js
function slowFib(n) {
  console.log('slowFib called with', n);
  if (n <= 1) return n;
  return slowFib(n - 1) + slowFib(n - 2);
}

const memo = {};

function memoFib(n) {
  if (memo[n] !== undefined) {
    return memo[n];
  }
  if (n <= 1) return (memo[n] = n);
  memo[n] = memoFib(n - 1) + memoFib(n - 2);
  return memo[n];
}
```

* `slowFib`는 같은 `n`을 여러 번 계산
* `memoFib`는 계산 결과를 `memo` 객체에 저장해 두고 **재사용**

**포인트:** “입력 → 출력”이 바뀌지 않는다면, 중간 과정(연산)을 생략하자.

리액트에서 메모이제이션도 **같은 아이디어**지만, “연산” 대신
**“렌더링, props 비교, 함수 인스턴스 생성, 무거운 계산 등”**을 줄이는 데 쓰입니다.

---

## 2. 리액트 렌더링과 메모이제이션 필요성 🔁

함수형 컴포넌트는 **그냥 자바스크립트 함수**입니다.

```jsx
function MyComponent(props) {
  // 렌더링 시마다 이 함수 전체가 다시 호출됨
  return <div>{props.value}</div>;
}
```

리액트는 다음과 같은 사이클로 돌아갑니다:

1. **상태/props 변경 감지**
2. 해당 컴포넌트(그리고 자식들)를 다시 렌더(함수 다시 호출)
3. 가상 DOM 트리 생성
4. 이전 트리와 비교(reconcile)
5. 실제 DOM 업데이트(commit)

여기서 비용이 드는 부분은:

* **컴포넌트 함수 호출 자체** (특히 무거운 연산이 있다면)
* **자식 컴포넌트들까지 줄줄이 다시 렌더**
* **렌더 안에서 실행되는 무거운 계산, 배열 필터링/정렬, memoized object 생성**

그래서 리액트는 **“굳이 다시 렌더 안 해도 되면 좀 건너뛰자”** 라는 escape hatch를 줍니다.
그게 바로:

* `React.memo` : 컴포넌트 자체를 메모이제이션
* `useMemo` : **값(계산 결과)** 메모이제이션
* `useCallback` : **함수(콜백)의 참조값** 메모이제이션

입니다.

---

## 3. `React.memo` – 컴포넌트 레벨 메모이제이션 🧱

### 3.1 기본 개념

```jsx
const MyComponent = (props) => {
  console.log('렌더링!');
  return <div>{props.value}</div>;
};

export default React.memo(MyComponent);
```

* `React.memo`는 **고차 컴포넌트(HOC)** 입니다.
* 같은 props로 다시 렌더링되려 할 때,

  * **이전 props와 현재 props를 shallow 비교**
  * 같다고 판단되면 **컴포넌트 함수 호출 자체를 스킵**합니다.
* 즉: **부모가 리렌더링되더라도, 자식이 같은 props를 받으면 리렌더를 건너뛸 수 있음**.

### 3.2 shallow 비교란? (얕은 비교)

```js
prevProps === nextProps   // ❌ 거의 항상 false (객체는 레퍼런스 비교)

Object.is(prevProps.a, nextProps.a)
Object.is(prevProps.b, nextProps.b)
// ... 각 필드를 일일이 비교 (리액트 내부 구현은 조금 다르지만 개념은 이 느낌)
```

즉:

* 원시값(number, string, boolean 등)은 값 비교
* 객체/배열/함수는 **참조(레퍼런스)** 비교

```js
{ foo: 1 } === { foo: 1 }  // false (다른 객체)
const obj = { foo: 1 };
obj === obj;               // true (같은 참조)
```

그래서 `React.memo`를 제대로 쓰려면 **“props의 참조 안정성”**을 보장해 줘야 합니다.

---

### 3.3 예제: 무거운 자식 리스트 아이템

```jsx
// HeavyChild.jsx
function HeavyChild({ item, onSelect }) {
  console.log('HeavyChild 렌더링:', item.id);
  // 아주 무거운 계산/렌더링이라고 가정
  return (
    <li onClick={() => onSelect(item.id)}>
      {item.name}
    </li>
  );
}

export default React.memo(HeavyChild);
```

```jsx
// Parent.jsx
import HeavyChild from './HeavyChild';

function Parent({ items }) {
  const handleSelect = (id) => {
    console.log('선택된 id:', id);
  };

  return (
    <ul>
      {items.map((item) => (
        <HeavyChild
          key={item.id}
          item={item}
          onSelect={handleSelect}
        />
      ))}
    </ul>
  );
}
```

여기서 문제:

* `Parent`가 새로 렌더될 때마다 `handleSelect`라는 **새 함수 인스턴스**가 생성됩니다.
* `React.memo`는 `onSelect` prop을 **레퍼런스 비교**하기 때문에,

  * `prev.onSelect !== next.onSelect`
  * → **항상 다른 함수로 보이고** → **항상 렌더**됩니다.
* 즉, `React.memo(HeavyChild)`가 **거의 효과가 없음**.

이를 해결하려면 **`handleSelect` 함수의 레퍼런스를 고정**해야 합니다.

---

## 4. `useCallback` – 함수 참조 메모이제이션 🎣

### 4.1 기본 개념

```jsx
const memoizedCallback = useCallback(
  () => {
    doSomething(a, b);
  },
  [a, b]
);
```

* `useCallback(fn, deps)`는

  * “같은 deps 배열”일 때 **이전 `fn`을 재사용**합니다.
  * 즉, `fn`의 **참조값(레퍼런스)**를 메모이제이션합니다.
* 사실상:
  `useCallback(fn, deps)` ≒ `useMemo(() => fn, deps)`

### 4.2 위 예제 리팩터링

```jsx
function Parent({ items }) {
  const handleSelect = useCallback((id) => {
    console.log('선택된 id:', id);
  }, []); // deps가 비어 있으므로, 최초 렌더 시 한 번만 생성

  return (
    <ul>
      {items.map((item) => (
        <HeavyChild
          key={item.id}
          item={item}
          onSelect={handleSelect}
        />
      ))}
    </ul>
  );
}
```

이제:

* `Parent`가 다시 렌더되더라도

  * `handleSelect`는 **같은 함수 레퍼런스**입니다.
* `HeavyChild` 입장에서는

  * `item`이 바뀌지 않았다면
  * `onSelect`도 이전과 동일한 레퍼런스이기 때문에
  * `React.memo`가 **렌더링을 건너뛸 수 있습니다.**

### 4.3 언제 `useCallback`을 써야 할까?

**좋은 사용처**:

1. `React.memo`된 자식에게 props로 콜백을 넘길 때
2. `useEffect` 의존성 배열에 안전하게 함수를 넣어야 할 때
3. `useMemo` 안에서 의존하는 콜백을 안정적으로 유지하고 싶을 때

**안 좋은 사용처 (과한 사용)**:

* 거의 모든 이벤트 핸들러에 무조건 `useCallback`을 붙이는 것

  * 코드는 복잡해지고, 이득은 거의 없음
  * `useCallback` 자체도 훅이므로 **비용이 있습니다.**
* 자식이 `React.memo`도 아니고, 콜백 레퍼런스 비교를 안 쓰는데 습관처럼 사용하는 경우

---

## 5. `useMemo` – 값(계산 결과) 메모이제이션 📦

### 5.1 기본 개념

```jsx
const memoizedValue = useMemo(() => {
  return heavyComputation(a, b);
}, [a, b]);
```

* `useMemo(factory, deps)`는:

  * **`deps`가 바뀔 때만 `factory` 함수를 실행**
  * 바뀌지 않으면 **이전 결과를 재사용**
* 메모이제이션 대상은 **“값”** 입니다.

  * 숫자, 문자열, 객체, 배열, 함수 등 어떤 값이든 가능

두 가지 대표 용도:

1. **무거운 계산 결과를 캐싱**
2. **객체/배열 레퍼런스 안정화(자식의 props/의존성용)**

---

### 5.2 예제 1: 무거운 계산 캐싱

```jsx
function FilteredList({ items, query }) {
  const filtered = useMemo(() => {
    console.log('무거운 필터링 실행');
    return items
      .filter((item) => item.name.includes(query))
      .sort((a, b) => a.name.localeCompare(b.name));
  }, [items, query]);

  return (
    <ul>
      {filtered.map((item) => (
        <li key={item.id}>{item.name}</li>
      ))}
    </ul>
  );
}
```

* 만약 `query`나 `items`가 바뀌지 않았는데 부모가 리렌더되어도:

  * `useMemo` 덕분에 필터 + 정렬 연산을 **건너뛸 수 있습니다.**

---

### 5.3 예제 2: 객체 레퍼런스 안정화 (React.memo와 협업)

```jsx
// Child.jsx
function Child({ options }) {
  console.log('Child 렌더링');
  return <div>옵션: {options.label}</div>;
}

export default React.memo(Child);
```

```jsx
// Parent.jsx
import Child from './Child';

function Parent({ label }) {
  const options = { label }; // ❌ 렌더마다 새 객체

  return <Child options={options} />;
}
```

위 코드에서는:

* 매 렌더마다 `{ label }`이 **새로운 객체**로 생성되므로

  * `React.memo(Child)`는 `options`가 매번 달라졌다고 판단
  * 매번 렌더

이를 고치려면:

```jsx
function Parent({ label }) {
  const options = useMemo(() => ({ label }), [label]);

  return <Child options={options} />;
}
```

이제:

* `label`이 같으면 `options` 객체가 **이전과 동일한 레퍼런스** 유지
* `Child`는 `React.memo` 덕분에 쓸데없는 렌더를 피할 수 있음

---

### 5.4 `useMemo` 오해와 주의점 ⚠️

1. **“useMemo 쓰면 무조건 성능이 좋아진다” → 오해**

   * `useMemo` 자체도 훅이므로 **비용이 있습니다.**
   * 아주 가벼운 계산에 붙이면, 오히려 이득보다 손해일 수 있습니다.
   * 진짜로 “비용이 큰 계산”에만 쓰는 것이 좋습니다.

2. **“useMemo가 리렌더를 막아준다” → 오해**

   * `useMemo`는 **“컴포넌트 내부의 계산”**을 캐싱할 뿐,
   * 컴포넌트 함수 자체가 실행되는 것은 막지 못합니다.
   * 리렌더 자체를 막는 것은 **`React.memo`**의 역할입니다.

3. **의존성 배열을 잘못 쓰면 “stale 값”을 참조**

   ```jsx
   const value = useMemo(() => count * 2, []); // ❌ count를 deps에 안 넣음
   ```

   * `[]`로 두면 처음 렌더 때 계산한 값만 영원히 사용
   * 이후 `count`가 변해도 `value`는 업데이트되지 않음
   * 의도된 “한 번만 계산” 패턴이 아니라면 **버그**입니다.

---

## 6. 내부 동작 – hook.memoizedState와 메모이제이션 ⚙️

이전에 질문 주셨던 `hook.memoizedState`와도 연결되는 부분입니다. 🙂

리액트는 각 컴포넌트의 훅들을 **“훅 슬롯(hook slot)”**으로 관리합니다.

* `useState` 슬롯: `memoizedState`에 **현재 state 값** 저장
* `useEffect` 슬롯: `memoizedState`에 `{ create, deps }` 형태로 저장
* `useMemo` 슬롯: `memoizedState`에 `{ value, deps }` 형태(혹은 유사 구조)로 저장
* `useCallback` 슬롯: `memoizedState`에 `{ callback, deps }` 구조로 저장

개념적으로 (의사 코드):

```js
function useMemo(factory, deps) {
  const hook = getCurrentHook(); // 이 컴포넌트에서 n번째 훅 슬롯

  if (hook.memoizedState) {
    const { value, prevDeps } = hook.memoizedState;
    if (areHookInputsEqual(prevDeps, deps)) {
      return value; // deps 동일 → 이전 값 재사용
    }
  }

  const nextValue = factory();
  hook.memoizedState = { value: nextValue, prevDeps: deps };
  return nextValue;
}
```

`useCallback`도 비슷하게:

```js
function useCallback(callback, deps) {
  const hook = getCurrentHook();

  if (hook.memoizedState) {
    const { fn, prevDeps } = hook.memoizedState;
    if (areHookInputsEqual(prevDeps, deps)) {
      return fn; // 같은 콜백 레퍼런스 재사용
    }
  }

  hook.memoizedState = { fn: callback, prevDeps: deps };
  return callback;
}
```

여기서 보듯이:

* **메모이제이션 = 훅 슬롯의 `memoizedState`에 값을 저장해 두었다가, deps가 같으면 재사용**
* `areHookInputsEqual`이 바로 **의존성 배열 비교 로직**입니다.

---

## 7. 세 가지 도구의 역할 정리 🔧

| 도구            | 무엇을 메모이제이션?         | 목적                     |
| ------------- | ------------------- | ---------------------- |
| `React.memo`  | **컴포넌트 렌더링 자체**     | props가 같으면 **렌더 건너뛰기** |
| `useMemo`     | **계산된 값(객체/배열 포함)** | 무거운 계산 캐싱, 레퍼런스 안정화    |
| `useCallback` | **함수 레퍼런스**         | 콜백 참조 안정화(자식/의존성 용)    |

세 개를 조합하는 전형적인 패턴:

```jsx
const Child = React.memo(function Child({ data, onClick }) {
  console.log('Child 렌더링');
  return <button onClick={onClick}>{data.label}</button>;
});

function Parent({ label }) {
  const data = useMemo(() => ({ label }), [label]);

  const handleClick = useCallback(() => {
    console.log('clicked');
  }, []);

  return <Child data={data} onClick={handleClick} />;
}
```

* `Child`는 `React.memo`로 감싸져 있음
* `data`는 `useMemo`로 객체 레퍼런스 안정화
* `onClick`은 `useCallback`으로 함수 레퍼런스 안정화
* `label`이 바뀌지 않으면, `Parent`가 리렌더되어도 `Child`는 렌더를 건너뜀

---

## 8. 언제 메모이제이션을 쓰고, 언제 안 써야 할까? ✅❌

### 8.1 사용하는 것이 좋은 경우 ✅

1. **리스트가 크고, 각 아이템 렌더링이 무거울 때**

   * 수백~수천 개 리스트 아이템
   * 각각 복잡한 UI or 비싼 계산

2. **부모가 자주 리렌더링되지만, 자식은 바뀌지 않는 경우**

   * 글로벌 스토어/컨텍스트 변화로 상위가 잦은 리렌더
   * 특정 부분은 실제로는 변경이 거의 없을 때

3. **비싼 계산이 있고, 결과가 자주 재사용될 때**

   * 정렬, 필터, 복잡한 수학 연산, 큰 데이터 변환 등
   * `useMemo`로 계산 결과 캐싱

4. **자식이 `React.memo`를 사용하고 있고, props로 콜백/객체를 넘길 때**

   * `useMemo` / `useCallback`으로 레퍼런스 안정화

---

### 8.2 사용하지 않는 것이 좋은 경우 ❌

1. **컴포넌트가 아주 단순하고, 렌더 비용이 거의 없을 때**

   * `<span>{count}</span>` 수준의 버튼/텍스트
   * 여기서는 메모이제이션 오버헤드가 더 클 수 있습니다.

2. **props가 항상 바뀌는 경우**

   * 예: 매번 랜덤 값, 매번 새로 만드는 객체 배열
   * `React.memo`의 비교 비용만 추가되고 효과는 없음

3. **의존성 배열 관리가 너무 복잡해지는 경우**

   * 유지보수에서 실수하기 쉬움
   * “stale 값” 버그가 더 치명적일 수 있음

4. **조기 최적화(Premature optimization)**

   * 실제 성능 문제가 관측되지 않은 상태에서 습관적으로 붙이는 것은 좋지 않습니다.
   * 먼저 **프로파일링(React DevTools Profiler)** 으로 병목을 찾는 것이 좋습니다.

---

## 9. 실전용 간단 체크리스트 📝

메모이제이션을 도입하기 전에 다음 질문을 던져 보시면 좋습니다:

1. 이 컴포넌트/계산은 **비용이 큰가?**
2. 같은 입력에 대해 **결과가 자주 재사용되는가?**
3. 상위 컴포넌트가 **자주 리렌더링**되지만, 이 부분은 잘 안 바뀌는가?
4. 메모이제이션 도입 후 코드 복잡도가 **심각하게 증가하지 않는가?**
5. `React.memo`를 쓰면서, props의 **레퍼런스 안정성**까지 제대로 고려했는가?

* **YES가 많을수록**: `React.memo` / `useMemo` / `useCallback`을 고려할 가치가 큽니다.
* **NO가 많다면**: 일단 단순하게 두고, 실제 성능 문제가 생겼을 때 최적화하는 것이 좋습니다.

---

## 마무리 🎯

정리하면, 리액트의 메모이제이션은

* **“렌더링과 계산의 중복을 줄이기 위한 전략”** 이고
* `React.memo`, `useMemo`, `useCallback`은 각각

  * 컴포넌트 렌더링
  * 값(계산 결과)
  * 함수 레퍼런스

를 대상으로 하는 **서로 다른 레벨의 메모이제이션 도구**입니다.
