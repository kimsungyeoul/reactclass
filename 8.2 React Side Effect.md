# 🚀 React Side Effect

## — “왜 리액트는 Side Effect를 분리하려 하는가?”를 내부 구조부터 파헤친다 —

React에서 “Side Effect(부작용)”는 단순히 “네트워크 요청 같은 것”을 말하는 것이 아닙니다.
진짜 중요한 핵심은 다음입니다.

> **React의 렌더링 시스템(Fiber Architecture)이 ‘순수 함수 기반’으로 설계되었기 때문에,
> 순수 계산을 방해하는 모든 것들이 Side Effect이며,
> React는 그것을 ‘별도의 Phase’에서만 처리하도록 강제한다.**


# 1️⃣ React에서 말하는 “Side Effect”는 왜 특별한가? 🤯

## — 렌더링 시스템이 “순수성(Purity)”을 강제하기 때문

React 컴포넌트 함수는 사실상 아래와 같은 “순수 함수”로 간주됩니다:

```tsx
// 순수 함수 (의도)
function Component(props, state) {
  return ReactElementTree;
}
```

즉, 렌더링 과정에서 **절대로 외부 세계를 바꿔서는 안 됩니다.**

### ✔ 왜 이렇게 강제할까?

React는 Fiber Architecture에서 아래 작업을 마음대로 합니다.

* 컴포넌트 **중단(suspend)**
* **다시 시작(resume)**
* **여러 번 재실행**
* **서로 다른 우선순위로 실행(priority scheduling)**
* StrictMode에서는 **effects를 일부러 2번 실행**
* 렌더는 **동기**나 **비동기**로 변할 수 있음(Concurrent Mode)

이런 환경에서 **렌더링 중에 Side Effect가 있어버리면?**

### ❌ 치명적인 문제 발생:

* 같은 컴포넌트가 재실행되면서 중복 네트워크 요청 발생
* DOM을 여러 번 잘못 조작
* 타이머가 중복 등록
* 스크롤/포커스가 비정상적으로 변함
* unpredictable UI

그래서 React는 선언합니다:

> 🚫 “Render Phase에서는 순수 계산만 해라.
> 🌱 Side Effect는 Commit Phase에서만 처리해라.”

이 구분이 **React Effect 시스템의 핵심 철학**입니다.

---

# 2️⃣ React의 렌더링 파이프라인: “두 단계 구조” 🧠

React 렌더링은 다음 두 단계로 나뉩니다:

```
🔵 Render Phase (계산 단계)
🔴 Commit Phase (실제 반영 단계)
```

## ✔ Render Phase

* Pure 계산 ⭕
* DOM 변경 ❌
* 외부 API 호출 ❌
* 네트워크 요청 ❌
* 타이머 설정 ❌

여기서는 오직:

* 각 컴포넌트를 호출하여 ReactElement를 만들고
* 어떤 DOM 변경이 필요한지 계산하고
* 동기/비동기 스케줄링을 유지하며
* Fiber Node 들을 준비(Work-In-Progress Tree)

즉, 이 단계에서는 Side Effect를 절대 실행하면 안 됩니다.

## ✔ Commit Phase

* React가 DOM을 업데이트
* ref 연결
* layout 계산
* effect 실행

즉,

> 🔥 **Side Effect는 Commit Phase에서만 실행된다.**

React는 이 Phase에서 두 가지 Effect List를 처리합니다.

---

# 3️⃣ React는 Effect를 실제로 “리스트”로 관리한다 📝

React Fiber Node는 다음과 같은 effectTag를 가집니다:

* Placement
* Update
* Deletion
* PassiveEffect
* LayoutEffect

그리고 Commit Phase에서 이 리스트를 순차적으로 탈며 실행합니다.

📌 즉,

* `useLayoutEffect` → Layout Effect Queue
* `useEffect` → Passive Effect Queue

이렇게 내부적으로 **두 종류의 Effect Queue**가 존재합니다.

---

# 4️⃣ 그럼 Side Effect는 어디서 실행될까? 👇

## ✔ `useLayoutEffect`

* Commit Phase 중 **DOM 업데이트 직후** 실행
* Browser Paint 전에 실행
* DOM measurement(높이, 너비 측정) 같은 작업에 적합

```
Commit Phase
└─ Mutation → LayoutEffect → Paint
```

## ✔ `useEffect`

* Commit Phase 이후
* Browser가 Paint까지 끝낸 후 비동기로 실행
* 사용자에게 UI가 보인 뒤 실행되므로 성능에 유리

```
Commit Phase
└─ Mutation → Paint → PassiveEffect(useEffect)
```

### 👉 결론

**useEffect는 UI를 깨끗하게 그린 뒤 실행되는 “후처리” 단계용이다.**

---

# 5️⃣ 왜 `render()` 안에서는 Side Effect가 위험한가? ⚡

React 18 Concurrent 렌더링은 아래와 같은 상황을 만든다.

```
Render Phase 실행
→ 중단
→ 다시 Render
→ 다시 중단
→ Commit 진행
```

즉,

> 🔁 Render Phase는 몇 번 실행될지 React 스스로도 모른다.

이때 Render Phase에서 아래처럼 하면?

```jsx
function App() {
  // ❌ 렌더 단계에서 외부 세계를 바꾸는 Side Effect
  fetch('/api/data');
  document.title = "Hello";

  return <div />;
}
```

문제:

* Render Phase 중단 → 다시 실행 → Side Effect 또 실행
* fetch 중복 호출
* title 반복 변경
* 타이머 중복 설정

React는 이 혼돈을 막기 위해 Side Effect의 실행 위치를 강제합니다.

---

# 6️⃣ 이벤트 핸들러는 예외일까? 🙋‍♂️

이벤트 핸들러는 Render Phase와 완전히 별개의 Phase입니다.

```jsx
<button onClick={() => {
  // ✔ Side Effect OK
  localStorage.setItem("x", "1");
}} />
```

왜 괜찮을까?

* 이벤트는 “사용자의 명령”
* React 렌더링 사이클에 속하지 않음
* 중단/재실행/비동기 스케줄링과 무관

즉, Side Effect는 이벤트 핸들러 안에서 자유롭게 작성할 수 있습니다.

---

# 7️⃣ useEffect와 사이드 이펙트의 상관관계 🎯

React는 공식 문서에서 이렇게 정의합니다:

> **Effect는 “렌더링 결과가 DOM에 반영된 뒤 실행해야 하는 동작”을 캡슐화한 것이다.**

즉, useEffect는 다음 작업을 수행할 때 사용합니다:

### ✔ UI 결과와 외부 세계 동기화

* document.title 변경
* 스크롤 위치 맞추기
* localStorage 동기화

### ✔ 구독/리스너 등록과 정리

* window.addEventListener
* WebSocket 연결
* Firebase 구독
* setInterval 타이머

### ✔ Async Data Fetching

* 서버에서 데이터 로딩
* Redux dispatch (비동기)

---

# 8️⃣ 의존성 배열(deps)은 “Side Effect의 스케줄링 조건”이다 ⏱️

React는 deps를 “effect의 실행 조건”이라고 보지 않습니다.
정확한 정의는 다음입니다.

> “Effect 내부에서 참조한 값들의 최신 스냅샷을 유지하기 위한 종속성 목록”

쉽게 말하면,

```
Effect는 ‘어떤 값이 변할 때 다시 실행될 필요가 있는가’를 선언하는 것
```

React는 렌더링마다 새 props/state를 생산하므로
deps를 잘못 적으면 stale closure 문제가 발생합니다.

---

# 9️⃣ useEffect의 실행 순서를 정확하게 이해해보자 🧩

컴포넌트 업데이트 과정은 다음과 같습니다:

```
1. Render Phase: 컴포넌트 함수 실행 (순수 계산)
2. Commit Phase: 실제 DOM 업데이트
3. Paint: 브라우저가 화면에 그림
4. Passive Effect Phase: useEffect 실행
```

### 🔥 Clean-up 순서도 중요

Effect A 가 있고 deps가 변경되면:

```
기존 Effect A의 cleanup 실행
↓
새 Effect A 실행
```

또한 Strict Mode에서는:

```
Effect 실행
→ cleanup
→ Effect 재실행
```

이는 “effect가 idempotent한지 검사하기 위함”입니다.

---

# 1️⃣0️⃣ 잘못된 Side Effect 예시들 🔥

## ❌ 1. 렌더 내부에서 side effect 실행

```jsx
function App() {
  localStorage.setItem('theme', 'dark');  // ❌
  return <div />;
}
```

## ❌ 2. 의존성 배열 누락

```jsx
useEffect(() => {
  console.log(count);
}, []); // ❌ count는 stale snapshot
```

## ❌ 3. 무한 루프

```jsx
useEffect(() => {
  setValue(value + 1);
}, [value]); // ❌ 매번 value 변경 → 무한 렌더링
```

---

# 1️⃣1️⃣ React Fiber 내부 구조에서 본 “Side Effect” 🌿

React Fiber는 각 컴포넌트(정확히는 각 Virtual Node)를 다음과 같이 관리합니다:

* stateNode
* memoizedState
* updateQueue
* effectTag (Side Effect 플래그)
* nextEffect (effect 리스트 연결)

렌더링이 끝나면 Commit Phase에서:

1. Mutation effects
2. Layout Effects (`useLayoutEffect`)
3. Passive Effects (`useEffect`)

를 순서대로 실행합니다.

즉,

> 🔥 React가 Side Effect를 “렌더링 후에 모아서 쓰는 이유는
> Fiber 구조 자체가 effect를 리스트로 관리하기 때문.”

---

# 1️⃣2️⃣ 한 문장 정리 ✨

> **React의 Side Effect는
> Render Phase(순수 계산)를 오염시키지 않기 위해
> Commit Phase에서만 실행되는 외부 세계와의 상호작용이며,
> 이 구조는 Fiber 아키텍처의 근본적인 동작 방식과 직결된다.**


