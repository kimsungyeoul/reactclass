웹 브라우저의 **Event Control Methods**는 한마디로 말해서
“이벤트가 **어떻게 흘러가고(전파)**, **브라우저가 기본 동작을 할지 말지**를 개발자가 직접 제어하는 도구들”입니다. ⚙️🖱️

---

## 1. 이벤트를 제어한다는 건 뭘까? 🤔

브라우저에서 어떤 일이 일어나면(클릭, 입력, 스크롤 등) **Event 객체**가 만들어져서
DOM 트리를 따라 **흐르면서(listener를 호출)** UI와 로직을 연결합니다.

우리가 조절할 수 있는 건 크게 세 가지입니다.

1. **이벤트 흐름(전파)을 멈출 것인가?**
2. **브라우저의 기본 동작을 막을 것인가?**

   * 예: `<a>` 링크 이동, `<form>` 제출, 텍스트 선택, 컨텍스트 메뉴 등
3. **리스너 자체를 어떻게 관리할 것인가?**

   * 한 번만 실행, 캡처 단계에서 실행, 스크롤 성능 최적화 등

이 세 가지를 제어하기 위해 사용하는 대표적인 메서드가 바로:

* `event.preventDefault()`
* `event.stopPropagation()`
* `event.stopImmediatePropagation()`
* (과거: `event.cancelBubble`)
* 그리고 `addEventListener`의 옵션들 `{ capture, once, passive, signal }` 입니다.

---

## 2. 이벤트 흐름 복습 🧭 (Capturing → Target → Bubbling)

**Event Control Methods**를 이해하려면 **이벤트 흐름**을 먼저 정확히 잡고 가야 합니다.

1. **Capturing Phase (캡처 단계)**

   * `window` → `document` → `html` → `body` → … → **타겟 요소**
   * 바깥에서 안으로 내려오면서 **캡처 단계 리스너** 호출

2. **Target Phase (타겟 단계)**

   * 실제 이벤트가 발생한 요소에서 리스너 호출

3. **Bubbling Phase (버블 단계)**

   * 타겟 요소 → 부모 → 그 부모 … → `document` → `window`
   * 안에서 바깥으로 올라가면서 **버블 단계 리스너** 호출

```html
<div id="outer">
  <div id="inner">Click me</div>
</div>
```

```js
outer.addEventListener('click', () => console.log('outer bubble'));
outer.addEventListener('click', () => console.log('outer capture'), { capture: true });
inner.addEventListener('click', () => console.log('inner'));
```

`#inner`를 클릭하면 호출 순서:

1. `outer` (capture)
2. `inner`
3. `outer` (bubble)

이 흐름 중간에서 **“더 이상 올라가지 마!”** 혹은
**“브라우저야, 너 기본 동작 하지 마!”**라고 말하는 게
Event Control Methods의 핵심입니다. 🧱

---

## 3. 브라우저 기본 동작 제어: `event.preventDefault()` 🚫

### 3-1. 역할

`event.preventDefault()`는

> “이 이벤트에 연결된 **브라우저의 기본 행동(기본 처리)을 하지 마라**”

라고 지시합니다.

대표적인 기본 동작 예시:

* `<a href="...">` 클릭 → **페이지 이동**
* `<form>` `submit` → **폼 제출 + 페이지 리로드**
* `contextmenu` → **우클릭 메뉴 표시**
* `wheel` 이벤트 → **스크롤 이동**
* `keydown` + `Ctrl+S` → **브라우저 저장창**
* `mousedown` → **텍스트 선택 시작**

### 3-2. 기본 예제 (링크 막기)

```html
<a href="https://google.com" id="googleLink">Go Google</a>
<script>
  const link = document.querySelector('#googleLink');

  link.addEventListener('click', (event) => {
    event.preventDefault(); // 브라우저의 링크 이동 막기
    console.log('링크 이동 막음, 커스텀 로직 실행');
    // SPA Router로 라우팅, 모달 오픈 등...
  });
</script>
```

이렇게 하면 사용자는 링크를 클릭했지만 **페이지는 이동하지 않고**,
우리가 넣은 JS 코드만 실행됩니다.

### 3-3. `event.cancelable`과 `event.defaultPrevented` ✅

모든 이벤트가 `preventDefault()`로 막을 수 있는 건 아닙니다.

* `event.cancelable === true` → 기본 동작을 막을 수 있음
* `event.cancelable === false` → 막을 수 없음

```js
element.addEventListener('click', (event) => {
  console.log(event.cancelable); // 클릭은 대개 true
  if (event.cancelable) {
    event.preventDefault();
  }
});
```

이미 다른 리스너가 `preventDefault()`를 호출했다면
`event.defaultPrevented`가 `true`가 됩니다.

```js
element.addEventListener('click', (event) => {
  if (event.defaultPrevented) {
    console.log('이미 기본 동작이 취소된 이벤트입니다.');
  }
});
```

### 3-4. `passive: true`와 `preventDefault` ⚡

`addEventListener`에서 `passive: true` 옵션을 사용하면:

```js
window.addEventListener('wheel', handler, { passive: true });
```

브라우저는 이렇게 이해합니다:

> “이 리스너 안에서는 **절대 `preventDefault()`를 호출하지 않을 거야**”

그래서 만약 콜백 안에서 `event.preventDefault()`를 호출하면 대부분의 브라우저에서:

* **경고 로그** 출력
* 실제로는 **기본 동작을 막지 못함**

`passive`는 주로 **스크롤 성능 최적화**를 위해 사용됩니다.
(브라우저가 스크롤을 미리 진행해도 안전하다고 판단)

---

## 4. 이벤트 전파 제어: `stopPropagation()` vs `stopImmediatePropagation()` 🧱

이벤트는 기본적으로 **버블링**(또는 캡처링) 하면서
각 단계에서 등록된 리스너들을 호출합니다.

이 흐름을 제어하는 것이 **전파 제어 메서드**입니다.

### 4-1. `event.stopPropagation()` 🌊✋

> “이 이벤트를 **더 이상 부모로 전파하지 말라**”

* **현재 타겟에 등록된 다른 리스너들은 그대로 실행**
* **부모 노드들로 올라가는 것만 차단**

```html
<div id="outer">
  <button id="btn">클릭</button>
</div>

<script>
  outer.addEventListener('click', () => {
    console.log('outer click');
  });

  btn.addEventListener('click', (event) => {
    console.log('button click');
    event.stopPropagation(); // 여기서 버블링 중단
  });
</script>
```

`btn`을 클릭하면:

* `button click`만 출력
* `outer click`은 **호출되지 않음**

---

### 4-2. `event.stopImmediatePropagation()` ⛔⛔

> “**이후에 호출될 리스너는 전부 실행하지 말고**,
> 부모로도 전파하지 마라”

즉:

1. **현재 요소에 등록된 나머지 리스너도 중단**
2. **부모 요소로의 버블링도 중단**

```js
button.addEventListener('click', () => {
  console.log('리스너 1');
});

button.addEventListener('click', (event) => {
  console.log('리스너 2 - 여기서 stopImmediatePropagation');
  event.stopImmediatePropagation();
});

button.addEventListener('click', () => {
  console.log('리스너 3');
});
```

버튼 클릭 시 출력:

* `리스너 1`
* `리스너 2 - 여기서 stopImmediatePropagation`
* `리스너 3` ❌ (호출 안 됨)

`stopPropagation()`을 썼다면:

* `리스너 1`
* `리스너 2`
* `리스너 3` ✅ (다 실행됨, 다만 부모로는 안 올라감)

---

### 4-3. `event.cancelBubble` (레거시) 🧓

옛날 IE 시절 남은 유산입니다.

```js
event.cancelBubble = true;
```

* 사실상 `event.stopPropagation()`과 동일
* 새로운 코드에서는 사용 안 하는 것이 좋고,
  **레거시 코드 리딩할 때만 이해**하고 있으면 충분합니다.

---

## 5. 이벤트 리스너 등록/해제와 제어 옵션들 🧩

이벤트 흐름을 제어하는 건 메서드뿐만 아니라
**리스너를 어떻게 등록하느냐**도 큰 영향을 줍니다.

### 5-1. `addEventListener` 기본형

```js
element.addEventListener(type, listener, options);
```

* `type`: `'click'`, `'submit'`, `'keydown'`, `'scroll'`, …
* `listener`: 콜백 함수 `(event) => { ... }`
* `options`: `boolean` 또는 객체

### 5-2. `capture` 옵션: 어느 단계에서 실행할 것인가? 🎯

```js
element.addEventListener('click', handler, { capture: true });
// 또는
element.addEventListener('click', handler, true); // 옛날 방식
```

* `capture: true` → **캡처 단계**에서 호출
* `capture: false`(기본값) → **버블 단계**에서 호출

캡처/버블의 차이는 **Event Control Methods와 조합**될 때 중요합니다.

```js
outer.addEventListener('click', (e) => {
  console.log('outer capture');
  e.stopPropagation();
}, { capture: true });

inner.addEventListener('click', () => {
  console.log('inner bubble');
});
```

`inner` 클릭 시:

* `outer capture` 호출
* `inner bubble`은 **아예 도달하지 못함**
  (캡처 단계에서 이미 막혀버림)

---

### 5-3. `once` 옵션: 한 번만 실행하기 🎇

```js
button.addEventListener('click', handler, { once: true });
```

* 최초 클릭 때 **한 번 실행 후 자동 제거**
* 수동으로 `removeEventListener`할 필요 없음
* 이벤트 기반 인증, 안내 모달, 일회성 초기화 등에 유용

---

### 5-4. `passive` 옵션: 스크롤 이벤트 최적화 ⚡

앞에서 잠깐 언급했지만, 다시 정리하면:

```js
window.addEventListener('touchmove', handler, { passive: true });
```

* 브라우저에게

  > “이 핸들러는 `preventDefault()` 절대 안 쓸 거야”
  > 라고 약속하는 것
* 브라우저는 **이벤트 처리 전에 스크롤을 기다릴 필요가 없어져서**
  스크롤 성능이 좋아짐

▶️ `preventDefault()`와 상충하므로,
**기본 동작을 막고 싶다면 절대 `passive: true`를 쓰면 안 됩니다.**

---

### 5-5. `signal` 옵션 + `AbortController` 🧨

여러 리스너를 한 번에 정리하고 싶을 때는:

```js
const controller = new AbortController();

button.addEventListener('click', handler, { signal: controller.signal });
window.addEventListener('resize', resizeHandler, { signal: controller.signal });

// 나중에 특정 시점에서
controller.abort(); // 위 두 리스너 모두 제거
```

* SPA에서 페이지 전환 시
  이전 페이지에 등록한 이벤트를 **일괄 정리**할 때 유용합니다.

---

### 5-6. `removeEventListener`로 수동 해제

```js
function handler(event) {
  console.log('clicked');
}

button.addEventListener('click', handler);
// ...
button.removeEventListener('click', handler);
```

❗중요:

* `removeEventListener`는 **같은 함수 참조**가 필요합니다.
* 익명 함수를 바로 넣으면 제거할 수 없습니다.

```js
button.addEventListener('click', () => {}); // 나중에 제거 불가능
```

그래서 실무에서는

* **이름 있는 함수**
* 또는 **변수에 담은 함수**를 쓰는 습관이 중요합니다.

---

## 6. Event Control Methods + 이벤트 위임 패턴 🧬

현대 웹에서는 **이벤트 위임(Event Delegation)**을 매우 자주 씁니다.

### 6-1. 이벤트 위임 기본 패턴

```html
<ul id="todoList">
  <li data-id="1">할 일 1</li>
  <li data-id="2">할 일 2</li>
  <li data-id="3">할 일 3</li>
</ul>
```

```js
const list = document.querySelector('#todoList');

list.addEventListener('click', (event) => {
  const li = event.target.closest('li');
  if (!li) return; // ul 빈 공간 클릭 등

  const id = li.dataset.id;
  console.log(id, '번 할 일 클릭');
});
```

* `li`마다 리스너를 달지 않고
* 부모인 `ul`에만 리스너를 달아서
* **버블링을 이용**해 자식의 이벤트를 처리하는 방식입니다.

여기서 `stopPropagation()`을 잘못 쓰면:

* **위임이 아예 작동하지 않거나**,
* 상위 컴포넌트에서 이벤트를 못 받는 상황이 발생합니다.

그래서 위임 패턴을 쓸 때는:

* 자식 요소 리스너에서는 웬만하면 **전파를 막지 않거나**,
* 매우 명시적인 이유가 있을 때만 `stopPropagation()`을 사용합니다.

---

## 7. 자주 쓰는 조합 예제들 🧪

### 7-1. 폼 제출 막고 Ajax로 처리하기

```html
<form id="loginForm">
  <input name="email" />
  <input name="password" type="password" />
  <button type="submit">로그인</button>
</form>
```

```js
const form = document.querySelector('#loginForm');

form.addEventListener('submit', async (event) => {
  event.preventDefault(); // 브라우저의 기본 제출 + 리로드 막기

  const formData = new FormData(form);
  const email = formData.get('email');
  const password = formData.get('password');

  // Ajax 호출
  const res = await fetch('/api/login', {
    method: 'POST',
    body: JSON.stringify({ email, password }),
    headers: { 'Content-Type': 'application/json' },
  });

  // 응답 처리...
});
```

여기서 핵심:

* **기본 submit 동작은 막고**
* 우리가 **직접 제어하는 로직**으로 대체

---

### 7-2. 모달 내부 클릭만 허용하고, 바깥 클릭 시 닫기

```html
<div id="backdrop" class="backdrop">
  <div id="modal" class="modal">
    <!-- 내용 -->
  </div>
</div>
```

```js
const backdrop = document.querySelector('#backdrop');
const modal = document.querySelector('#modal');

backdrop.addEventListener('click', () => {
  console.log('모달 닫기');
  backdrop.style.display = 'none';
});

// 모달 내부를 클릭했을 때는 버블링으로 backdrop까지 가지 않게 막기
modal.addEventListener('click', (event) => {
  event.stopPropagation(); // 여기 핵심
});
```

* 바깥 영역(backdrop)을 클릭하면 모달을 닫고,
* 모달 내부를 클릭하면 **닫히지 않게** 하는 패턴입니다.

---

### 7-3. 한 번만 실행되는 안내 메시지

```js
const button = document.querySelector('#dangerButton');

button.addEventListener(
  'click',
  () => {
    alert('이 버튼은 바로 실제 서버에 반영됩니다. 신중히 사용하세요!');
  },
  { once: true } // 처음 한 번만 실행
);
```

* 사용자가 첫 클릭 때만 안내 받도록 하고,
* 그 이후부터는 바로 동작하게 만들 수 있습니다.

---

## 8. 흔한 실수 & 주의사항 ⚠️

### 8-1. `return false`와 `preventDefault` 혼동하기

jQuery 시절 패턴:

```js
$('a').on('click', function (e) {
  e.preventDefault();
  e.stopPropagation();
});
```

혹은

```js
$('a').on('click', function () {
  return false; // jQuery에서만: preventDefault + stopPropagation
});
```

**순수 DOM 이벤트**에서는:

* `return false;`는 그냥 **그 함수의 반환값**일 뿐,
* **자동으로 기본 동작/전파를 막아주지 않습니다.**

```js
link.addEventListener('click', (event) => {
  // 이건 아무것도 안 막음
  return false;
});
```

👉 요즘 코드는 반드시 **명시적으로**
`event.preventDefault()` / `event.stopPropagation()`을 사용해야 합니다.

---

### 8-2. `stopPropagation()` 남발하기

* 디버깅 어려워짐
* 상위 레이아웃/컴포넌트가 **이벤트를 못 받는 상황** 발생
* 특히 React/Vue 같은 프레임워크 위에서 DOM 이벤트를 직접 다룰 때
  **프레임워크의 이벤트 시스템과 충돌**할 수 있습니다.

❗ **정말 필요할 때만, 의도를 명확히 하고 사용하는 게 좋습니다.**

---

### 8-3. `passive: true`인데 `preventDefault()` 호출하기

```js
window.addEventListener('wheel', (event) => {
  event.preventDefault(); // ❌ passive:true면 에러/경고
}, { passive: true });
```

→ 이 경우 **기본 동작은 막히지 않습니다.**
스크롤 방지를 하고 싶다면 `passive: false`(기본값)를 유지해야 합니다.

---

### 8-4. `removeEventListener`가 안 먹는 이유

```js
button.addEventListener('click', () => console.log('hi'));
// ...
button.removeEventListener('click', () => console.log('hi')); // ❌ 이건 다른 함수
```

* 서로 **다른 함수 참조**이기 때문에 제거되지 않습니다.
* 이름 있는 함수 / 변수에 넣은 함수 사용 습관이 매우 중요합니다.

---

## 9. 마무리 정리 📝

**Event Control Methods**는 결국 다음을 제어합니다:

1. **기본 동작 제어**

   * `event.preventDefault()`
   * `event.cancelable`, `event.defaultPrevented`
   * `passive` 옵션과의 관계

2. **전파 제어**

   * `event.stopPropagation()`
   * `event.stopImmediatePropagation()`
   * 레거시 `event.cancelBubble`
   * 캡처/버블 흐름과의 조합

3. **리스너 제어**

   * `addEventListener` 옵션 `{ capture, once, passive, signal }`
   * `removeEventListener`를 위한 함수 참조 관리
   * `AbortController`를 활용한 일괄 정리

4. **실전 패턴**

   * 폼 제출 커스텀 처리
   * 모달/드롭다운 클릭 처리
   * 이벤트 위임 (Delegation)
   * 일회성 안내/경고 처리

이 개념들을 정확히 잡으면
이후에 **React의 Synthetic Event**, **Vue의 이벤트 시스템**,
그리고 SPA 라우팅, 모달, 드롭다운, 드래그&드롭 등에서
이벤트를 훨씬 **의도대로, 안정적으로** 컨트롤할 수 있습니다. 💪


