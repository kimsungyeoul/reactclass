리액트 함수 컴포넌트의 *Component Lifecycle*은
**“Hook(useEffect, useLayoutEffect 등)이 언제, 어떤 순서로 실행되는가”** 를 이해하는 것과 같습니다. 🔄

즉, 이제는 **메서드 이름(componentDidMount 같은 것: 과거 리액트에서 사용하던 클래스형 컴포넌트의 라이프 사이클 메서드)** 이 아니라
➡️ **렌더링 단계(Render/Commit) + Hook 실행 타이밍 + cleanup**
이 조합으로 라이프사이클을 생각해야 합니다.

이 글에서는:

* 렌더링 단계(Render / Commit) 🧠
* `useEffect` / `useLayoutEffect`의 실행 타이밍 ⏱️
* mount / update / unmount 흐름 🔁
* StrictMode에서의 “두 번 실행” 이슈 🧪
* 커스텀 훅으로 라이프사이클 패턴 재사용하기 🧩

까지 정리해보겠습니다.

---

## 1. 컴포넌트 “라이프사이클”이란? 🔍

함수 컴포넌트는 클래스처럼 인스턴스가 없고,
**그냥 함수가 호출되는 것**일 뿐입니다.

```jsx
function MyComponent(props) {
  // 함수 본문 = 렌더링 시마다 다시 실행
  return <div>{props.message}</div>;
}
```

그래서 함수 컴포넌트의 라이프사이클은 이렇게 정의할 수 있습니다:

> **“컴포넌트 함수가 렌더링 될 때마다 어떤 Hook들이
> 어떤 순서로 실행되고, 언제 정리(cleanup)되는가”**

이걸 이해하려면 먼저 React 렌더링의 큰 그림을 봐야 합니다.

---

## 2. Render Phase vs Commit Phase 🧠🏗️

리액트 16+ (Fiber 기반)에서 렌더링은 크게 두 단계입니다.

### 2-1. Render Phase (렌더 단계) ✏️

* 컴포넌트 함수가 **호출되는 단계**
* `useState`, `useMemo`, `useCallback` 등 훅들이 **“어떤 값을 쓸지” 계산**하는 단계
* 아직 DOM에는 **손대지 않습니다** ❌
* 브라우저 화면에도 **아직 변화가 없습니다.**

> 중요한 규칙
> 👉 **Render Phase에서는 사이드 이펙트를 실행하면 안 됩니다.**
> 네트워크 요청, 이벤트 등록, DOM 조작 등은 모두 금지.

### 2-2. Commit Phase (커밋 단계) 🏗️

* Render Phase에서 계산된 변경 사항을 바탕으로
* 실제 DOM을 **추가/수정/삭제**하는 단계.
* 이때 브라우저 화면이 **실제로 업데이트**됩니다.
* DOM 반영이 끝난 뒤:

  * `useEffect` / `useLayoutEffect`의 **콜백과 cleanup**이 실행됩니다.

> 요약하면:
>
> * Render Phase → “설계도 그리기”
> * Commit Phase → “실제 공사 + 사후 처리(Effect)”

함수 컴포넌트의 라이프사이클은
**“렌더 → 커밋 → effect 실행 → 다음 렌더 전 cleanup”**
이 패턴의 반복입니다.

---

## 3. 라이프사이클을 한눈에 보여주는 함수 컴포넌트 예제 🔄

### 3-1. App: 자식 컴포넌트 mount/unmount + 부모 state 업데이트

```jsx
// App.jsx
import { useState } from 'react';
import LifecycleDemo from './LifecycleDemo';

function App() {
  const [show, setShow] = useState(true);
  const [parentCount, setParentCount] = useState(0);

  return (
    <div>
      <h1>함수 컴포넌트 라이프사이클 데모 🔄</h1>

      <button onClick={() => setShow(prev => !prev)}>
        {show ? '자식 컴포넌트 언마운트하기' : '자식 컴포넌트 마운트하기'}
      </button>

      <button onClick={() => setParentCount(c => c + 1)}>
        부모 state 변경 (+1): {parentCount}
      </button>

      <hr />

      {show && <LifecycleDemo parentCount={parentCount} />}
    </div>
  );
}

export default App;
```

### 3-2. LifecycleDemo: 다양한 `useEffect` 조합

```jsx
// LifecycleDemo.jsx
import { useEffect, useState } from 'react';

function LifecycleDemo({ parentCount }) {
  const [count, setCount] = useState(0);

  // 1) 마운트 시 한 번 + 언마운트 시 한 번
  useEffect(() => {
    console.log('✅ [마운트] LifecycleDemo가 화면에 나타남');

    return () => {
      console.log('🧹 [언마운트] LifecycleDemo가 화면에서 사라짐');
    };
  }, []);

  // 2) parentCount가 변할 때마다
  useEffect(() => {
    console.log('🔁 [업데이트] parentCount 변경:', parentCount);

    return () => {
      console.log('🧹 [업데이트 cleanup] parentCount 변경 직전 또는 언마운트');
    };
  }, [parentCount]);

  // 3) 매 렌더링 후
  useEffect(() => {
    console.log('📌 [매 렌더링 후] count =', count);

    return () => {
      console.log('🧹 [매 렌더링 cleanup] 다음 렌더 전 or 언마운트');
    };
  });

  return (
    <div style={{ border: '1px solid gray', padding: 16, marginTop: 16 }}>
      <h2>자식 컴포넌트</h2>
      <p>부모에서 받은 parentCount: {parentCount}</p>
      <p>자기 자신의 count: {count}</p>
      <button onClick={() => setCount(c => c + 1)}>자기 count +1</button>
    </div>
  );
}

export default LifecycleDemo;
```

이 예제를 기준으로 **라이프사이클 타임라인**을 뜯어봅시다. 🧷

---

## 4. Mount / Update / Unmount 타임라인 완전 해부 🧬

### 4-1. 처음 렌더 (Mount) 시 어떤 일이? 🍼

1. `App` 함수가 호출되고 `show === true`, `<LifecycleDemo />` 렌더
2. `LifecycleDemo` 함수 호출 (Render Phase)

   * `useState(0)` → `count = 0`
   * 아직 `useEffect`의 콜백은 실행되지 않음 (Render 단계라서)
3. React가 DOM을 실제로 그림 (Commit Phase)
4. 커밋 후, effect 실행 순서:

   * `useEffect(..., [])` 콜백 실행
     → `✅ [마운트] ...`
   * `useEffect(..., [parentCount])` 콜백 실행
     → `🔁 [업데이트] parentCount 변경: 0` (최초 값도 “변경”이라고 봄)
   * `useEffect(... )` (deps 없음) 콜백 실행
     → `📌 [매 렌더링 후] count = 0`

> 즉, “마운트 시”에도 **각 effect는 한 번씩 실행**됩니다.
> 단, 타이밍은 “렌더 이후, 커밋 직후”입니다.

---

### 4-2. 부모 state 변경 시 (Update – 부모로 인한 재렌더) 🔁

부모에서 버튼 클릭:

```jsx
<button onClick={() => setParentCount(c => c + 1)}>
```

1. `setParentCount` 호출 → `App`가 다시 렌더(Render Phase)
2. `App`가 `<LifecycleDemo parentCount={1} />`를 다시 호출
3. `LifecycleDemo` 함수가 다시 실행 (Render Phase)

   * `useState`는 기존 상태 (`count`)를 유지
   * 화면에 그릴 JSX를 다시 계산
4. DOM 업데이트 (Commit Phase)
5. Commit 이후 effect 순서:

   * 우선 **모든 기존 effect의 cleanup**이 실행

     * `🧹 [매 렌더링 cleanup] ...`
     * `🧹 [업데이트 cleanup] parentCount 변경 직전 ...`
   * 그 다음 **새로운 effect 콜백**들이 deps 조건에 따라 실행

     * `useEffect(..., [])` → deps 변화 없음 → 이번에는 실행 X
     * `useEffect(..., [parentCount])` → parentCount 변경됨 → 콜백 실행
       → `🔁 [업데이트] parentCount 변경: 1`
     * deps 없는 `useEffect` → 항상 실행
       → `📌 [매 렌더링 후] count = 0`

> 포인트 ✨
>
> * effect는 “렌더마다 새로 등록”되고
> * **다음 effect 실행 전에 이전 effect의 cleanup이 먼저 호출**됩니다.

---

### 4-3. 자식 자신의 state 변경 (Update – 자기 자신으로 인한 리리렌더) 🔁

`자기 count +1` 버튼 클릭:

```jsx
<button onClick={() => setCount(c => c + 1)}>자기 count +1</button>
```

1. `setCount` 호출 → `LifecycleDemo`만 다시 렌더 (부모는 그대로)
2. Render Phase:

   * `count`가 1로 바뀐 상태로 JSX 계산
3. Commit Phase:

   * DOM 반영
   * 이전 effect cleanup → 새 effect 콜백 실행 순서 반복:

     * `useEffect(..., [])`

       * deps 없음 → **다시 실행되지 않음** (mount 때만 실행)
     * `useEffect(..., [parentCount])`

       * `parentCount`는 바뀌지 않음 → 실행 X
     * deps 없는 `useEffect`:

       * cleanup → `🧹 [매 렌더링 cleanup] ...`
       * 콜백 → `📌 [매 렌더링 후] count = 1`

---

### 4-4. 언마운트(Unmount) 시 ⚰️

`자식 컴포넌트 언마운트하기` 버튼 클릭:

1. `show`가 false가 되면서 `<LifecycleDemo />`가 트리에서 제거
2. Commit Phase에서 DOM에서 해당 영역 제거
3. 이 컴포넌트에 등록된 모든 effect의 **cleanup**이 실행:

   * `🧹 [매 렌더링 cleanup] ...`
   * `🧹 [업데이트 cleanup] ...`
   * `🧹 [언마운트] LifecycleDemo가 화면에서 사라짐`

> 정리하면:
>
> * **mount**: effect 콜백 실행
> * **update**: 이전 effect cleanup → 새 effect 콜백
> * **unmount**: 마지막 cleanup만 실행

이 패턴이 함수 컴포넌트 라이프사이클의 핵심입니다. 🔑

---

## 5. `useEffect` 패턴별 라이프사이클 의미 정리 📊

### 5-1. `useEffect(effect, [])` – “초기 한 번 + 정리 한 번”

```jsx
useEffect(() => {
  // 컴포넌트가 처음 나타난 이후 한 번 실행
  console.log('초기 구독/초기 데이터 로드');

  return () => {
    // 컴포넌트가 사라질 때 한 번 실행
    console.log('구독 해제/리소스 정리');
  };
}, []);
```

* **마운트 후 한 번** 실행
* **언마운트 시 cleanup 한 번** 실행
* 전형적인 용도:

  * WebSocket 구독 시작/해제
  * `setInterval` 시작/clear
  * 외부 라이브러리 인스턴스 생성/파괴

---

### 5-2. `useEffect(effect, [deps])` – “특정 값이 변할 때”

```jsx
useEffect(() => {
  console.log('userId가 바뀔 때마다 실행', userId);
  // 데이터 fetch...

  return () => {
    console.log('userId 변경 직전 또는 언마운트 시 정리');
  };
}, [userId]);
```

* **마운트 직후** + `deps`가 변할 때마다 실행
* 실행 순서:

  1. 이전 effect cleanup
  2. 새 effect 콜백

> 이 패턴으로 “특정 state/props의 변화에 반응하는 사이드 이펙트”를 구현합니다.

---

### 5-3. `useEffect(effect)` – deps 없음 = “매 커밋마다”

```jsx
useEffect(() => {
  console.log('모든 렌더링 후 실행');

  return () => {
    console.log('다음 렌더 또는 언마운트 전 cleanup');
  };
});
```

* 모든 commit 이후마다 실행
* 대부분의 경우 성능 부담이 될 수 있으니
  정말 필요한 경우에만 사용합니다.

---

## 6. 레이아웃/스크롤 제어: `useLayoutEffect` 라이프사이클 🧱

`useLayoutEffect`는 **DOM이 커밋된 직후, 페인트 전에 동기적으로** 실행됩니다.

### 6-1. 채팅 리스트에서 스크롤 유지 예제

```jsx
import { useEffect, useLayoutEffect, useRef, useState } from 'react';

function ChatList({ messages }) {
  const listRef = useRef(null);
  const [autoScroll, setAutoScroll] = useState(true);

  // 사용자가 스크롤을 올렸는지 감지
  useEffect(() => {
    const el = listRef.current;

    function handleScroll() {
      const nearBottom =
        el.scrollHeight - el.scrollTop - el.clientHeight < 10;
      setAutoScroll(nearBottom);
    }

    el.addEventListener('scroll', handleScroll);
    return () => el.removeEventListener('scroll', handleScroll);
  }, []);

  // messages 변경 후, DOM 커밋 직후에 스크롤 위치 조정
  useLayoutEffect(() => {
    const el = listRef.current;
    if (autoScroll) {
      el.scrollTop = el.scrollHeight;
    }
  }, [messages, autoScroll]);

  return (
    <div
      ref={listRef}
      style={{ height: 300, overflowY: 'auto', border: '1px solid #ccc' }}
    >
      {messages.map(m => (
        <div key={m.id}>
          <strong>{m.user}</strong>: {m.text}
        </div>
      ))}
    </div>
  );
}
```

여기서 라이프사이클 흐름은:

1. `messages` 변경 → `ChatList` 렌더 (Render Phase)
2. DOM 업데이트 (Commit Phase)
3. **바로 직후** `useLayoutEffect` 실행 → 스크롤 위치 조정
4. 그 다음 브라우저가 화면을 페인트

> 결과: 사용자는 “스크롤이 튀기 전에” 이미 조정된 UI만 보게 됩니다.
> (레이아웃 플리커 방지 ✨)

일반 규칙:

* **레이아웃/스크롤/DOM 측정** 👉 `useLayoutEffect`
* 일반적인 비동기 로직/데이터 fetch/로그 👉 `useEffect`

---

## 7. StrictMode와 “두 번 실행” 이슈 🧪

개발 모드에서 `<React.StrictMode>` 안에 렌더링하면:

* 일부 동작이 **의도적으로 두 번 실행**됩니다.

  * 컴포넌트 함수 호출
  * `useEffect`의 cleanup + 콜백

목적:

* 렌더링 중에 **순수하지 않은(side effect가 섞인) 코드**를 찾기 위함입니다.

예를 들어:

```jsx
function Demo() {
  useEffect(() => {
    console.log('effect 실행');

    return () => {
      console.log('cleanup 실행');
    };
  }, []);

  console.log('렌더링 중');

  return <div>Demo</div>;
}
```

StrictMode + 개발 모드에서는 콘솔에서 대략 이런 패턴을 볼 수 있습니다:

1. 렌더링 중
2. effect 실행
3. cleanup 실행
4. 렌더링 중
5. effect 실행

실제 프로덕션 빌드에서는 **한 번만** 실행됩니다.

> 따라서 라이프사이클을 설계할 때:
>
> * effect는 항상 **여러 번 실행돼도 안전하게** 작성해야 하고
> * cleanup은 항상 **정상적으로 리소스를 정리**하도록 만들어야 합니다.

---

## 8. 커스텀 훅으로 “라이프사이클 패턴” 재사용하기 🧩

함수 컴포넌트의 강력한 점은
라이프사이클 로직을 **커스텀 훅으로 캡슐화**할 수 있다는 것입니다.

### 8-1. `useMount` – mount 시 한 번만 실행

```jsx
// useMount.js
import { useEffect } from 'react';

export function useMount(callback) {
  useEffect(() => {
    callback();
  }, []);
}
```

사용:

```jsx
import { useMount } from './useMount';

function MyComponent() {
  useMount(() => {
    console.log('마운트 시 한 번만 실행');
  });

  return <div>...</div>;
}
```

---

### 8-2. `useUnmount` – unmount 시 정리 전용

```jsx
// useUnmount.js
import { useEffect } from 'react';

export function useUnmount(callback) {
  useEffect(() => {
    return () => {
      callback();
    };
  }, []);
}
```

사용:

```jsx
import { useUnmount } from './useUnmount';

function MyComponent() {
  useUnmount(() => {
    console.log('언마운트 시 정리');
  });

  return <div>...</div>;
}
```

---

### 8-3. `useUpdateEffect` – “마운트 때는 실행하지 않고 업데이트 때만” 🔁

```jsx
// useUpdateEffect.js
import { useEffect, useRef } from 'react';

export function useUpdateEffect(effect, deps) {
  const isFirst = useRef(true);

  useEffect(() => {
    if (isFirst.current) {
      isFirst.current = false;
      return;
    }
    return effect();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, deps);
}
```

사용:

```jsx
import { useUpdateEffect } from './useUpdateEffect';

function SearchBox({ keyword }) {
  useUpdateEffect(() => {
    console.log('키워드 변경 시에만 실행 (최초 마운트는 제외)', keyword);
    // 검색 API 요청 등
  }, [keyword]);

  return <input value={keyword} readOnly />;
}
```


---

## 9. 함수 컴포넌트 라이프사이클 사고방식 정리 🎯

마지막으로, 함수 컴포넌트에서 라이프사이클을 이렇게 정리하시면 좋습니다:

1. **렌더 함수(컴포넌트 함수)는 항상 순수해야 한다.**

   * props/state → JSX 계산만
   * 사이드 이펙트 금지 (네트워크, DOM, 이벤트 등록 등)

2. **사이드 이펙트는 항상 Effect 훅 안에서만.**

   * `useEffect` / `useLayoutEffect`
   * 그리고 항상 cleanup으로 “되돌릴 수 있어야” 한다.

3. **Mount / Update / Unmount는 effect/cleanup 조합으로 표현된다.**

   * mount 후: effect 콜백
   * update: 이전 cleanup → 새 effect 콜백
   * unmount: 마지막 cleanup

4. **StrictMode를 고려해 여러 번 실행돼도 안전한 코드를 작성한다.**

   * effect에서 외부 상태를 다룰 때 특히 주의
   * 타이머, 구독, DOM 리스너는 반드시 cleanup에서 정리

5. **복잡한 라이프사이클 로직은 커스텀 훅으로 캡슐화한다.**

   * `useMount`, `useUnmount`, `useUpdateEffect`, `useEventListener`, `useInterval` 등

